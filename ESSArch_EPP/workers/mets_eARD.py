#!/usr/bin/env python
# -*- coding: utf-8 -*- 
'''
    ESSArch - ESSArch is an Electronic Archive system
    Copyright (C) 2010-2013  ES Solutions AB, Henrik Ek

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Contact information:
    Web - http://www.essolutions.se
    Email - essarch@essolutions.se
'''
__majorversion__ = "2.5"
__revision__ = "$Revision$"
__date__ = "$Date$"
__author__ = "$Author$"
import re
__version__ = '%s.%s' % (__majorversion__,re.sub('[\D]', '',__revision__))
#
# Generated Wed Sep 12 13:21:13 2012 by generateDS.py version 2.7c.
#

import sys
import getopt
import re as re_

Verbose_parse_ = False
etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class metsType(GeneratedsSuper):
    """metsType: Complex Type for METS Sections A METS document consists of
    seven possible subsidiary sections: metsHdr (METS document
    header), dmdSec (descriptive metadata section), amdSec
    (administrative metadata section), fileGrp (file inventory
    group), structLink (structural map linking), structMap
    (structural map) and behaviorSec (behaviors section). ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    OBJID (string/O): Is the primary identifier assigned to the METS
    object as a whole. Although this attribute is not required, it
    is strongly recommended. This identifier is used to tag the
    entire METS object to external systems, in contrast with the ID
    identifier. Made the attribut mandatory instead of optional,
    Karin BredenbergLABEL (string/O): Is a simple title string used
    to identify the object/entity being described in the METS
    document for the user. TYPE (string/O): Specifies the class or
    type of the object, e.g.: book, journal, stereograph, dataset,
    video, etc.Made the attribut mandatory instead of optional,
    Karin BredenbergAdded valuelist, Karin BredenbergRemoved type,
    Karin Bredenberg type="xsd:string" PROFILE (string/O): Indicates
    to which of the registered profile(s) the METS document
    conforms. For additional information about PROFILES see Chapter
    5 of the METS Primer. Made the attribut mandatory instead of
    optional, Karin Bredenberg"""
    subclass = None
    superclass = None
    def __init__(self, PROFILE=None, LABEL=None, TYPE=None, ID=None, OBJID=None, metsHdr=None, dmdSec=None, amdSec=None, fileSec=None, structMap=None, structLink=None, behaviorSec=None, extensiontype_=None):
        self.PROFILE = _cast(None, PROFILE)
        self.LABEL = _cast(None, LABEL)
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.OBJID = _cast(None, OBJID)
        self.metsHdr = metsHdr
        if dmdSec is None:
            self.dmdSec = []
        else:
            self.dmdSec = dmdSec
        if amdSec is None:
            self.amdSec = []
        else:
            self.amdSec = amdSec
        self.fileSec = fileSec
        if structMap is None:
            self.structMap = []
        else:
            self.structMap = structMap
        self.structLink = structLink
        if behaviorSec is None:
            self.behaviorSec = []
        else:
            self.behaviorSec = behaviorSec
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if metsType.subclass:
            return metsType.subclass(*args_, **kwargs_)
        else:
            return metsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metsHdr(self): return self.metsHdr
    def set_metsHdr(self, metsHdr): self.metsHdr = metsHdr
    def get_dmdSec(self): return self.dmdSec
    def set_dmdSec(self, dmdSec): self.dmdSec = dmdSec
    def add_dmdSec(self, value): self.dmdSec.append(value)
    def insert_dmdSec(self, index, value): self.dmdSec[index] = value
    def get_amdSec(self): return self.amdSec
    def set_amdSec(self, amdSec): self.amdSec = amdSec
    def add_amdSec(self, value): self.amdSec.append(value)
    def insert_amdSec(self, index, value): self.amdSec[index] = value
    def get_fileSec(self): return self.fileSec
    def set_fileSec(self, fileSec): self.fileSec = fileSec
    def get_structMap(self): return self.structMap
    def set_structMap(self, structMap): self.structMap = structMap
    def add_structMap(self, value): self.structMap.append(value)
    def insert_structMap(self, index, value): self.structMap[index] = value
    def get_structLink(self): return self.structLink
    def set_structLink(self, structLink): self.structLink = structLink
    def get_behaviorSec(self): return self.behaviorSec
    def set_behaviorSec(self, behaviorSec): self.behaviorSec = behaviorSec
    def add_behaviorSec(self, value): self.behaviorSec.append(value)
    def insert_behaviorSec(self, index, value): self.behaviorSec[index] = value
    def get_PROFILE(self): return self.PROFILE
    def set_PROFILE(self, PROFILE): self.PROFILE = PROFILE
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_OBJID(self): return self.OBJID
    def set_OBJID(self, OBJID): self.OBJID = OBJID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='metsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='metsType'):
        if self.PROFILE is not None and 'PROFILE' not in already_processed:
            already_processed.append('PROFILE')
            outfile.write(' PROFILE=%s' % (self.gds_format_string(quote_attrib(self.PROFILE).encode(ExternalEncoding), input_name='PROFILE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.OBJID is not None and 'OBJID' not in already_processed:
            already_processed.append('OBJID')
            outfile.write(' OBJID=%s' % (self.gds_format_string(quote_attrib(self.OBJID).encode(ExternalEncoding), input_name='OBJID'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='metsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metsHdr is not None:
            self.metsHdr.export(outfile, level, namespace_, name_='metsHdr', pretty_print=pretty_print)
        for dmdSec_ in self.dmdSec:
            dmdSec_.export(outfile, level, namespace_, name_='dmdSec', pretty_print=pretty_print)
        for amdSec_ in self.amdSec:
            amdSec_.export(outfile, level, namespace_, name_='amdSec', pretty_print=pretty_print)
        if self.fileSec is not None:
            self.fileSec.export(outfile, level, namespace_, name_='fileSec', pretty_print=pretty_print)
        for structMap_ in self.structMap:
            structMap_.export(outfile, level, namespace_, name_='structMap', pretty_print=pretty_print)
        if self.structLink is not None:
            self.structLink.export(outfile, level, namespace_, name_='structLink', pretty_print=pretty_print)
        for behaviorSec_ in self.behaviorSec:
            behaviorSec_.export(outfile, level, namespace_, name_='behaviorSec', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.metsHdr is not None or
            self.dmdSec or
            self.amdSec or
            self.fileSec is not None or
            self.structMap or
            self.structLink is not None or
            self.behaviorSec
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PROFILE is not None and 'PROFILE' not in already_processed:
            already_processed.append('PROFILE')
            showIndent(outfile, level)
            outfile.write('PROFILE = "%s",\n' % (self.PROFILE,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.OBJID is not None and 'OBJID' not in already_processed:
            already_processed.append('OBJID')
            showIndent(outfile, level)
            outfile.write('OBJID = "%s",\n' % (self.OBJID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metsHdr is not None:
            showIndent(outfile, level)
            outfile.write('metsHdr=model_.metsHdrType(\n')
            self.metsHdr.exportLiteral(outfile, level, name_='metsHdr')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('dmdSec=[\n')
        level += 1
        for dmdSec_ in self.dmdSec:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            dmdSec_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('amdSec=[\n')
        level += 1
        for amdSec_ in self.amdSec:
            showIndent(outfile, level)
            outfile.write('model_.amdSecType(\n')
            amdSec_.exportLiteral(outfile, level, name_='amdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.fileSec is not None:
            showIndent(outfile, level)
            outfile.write('fileSec=model_.fileSecType(\n')
            self.fileSec.exportLiteral(outfile, level, name_='fileSec')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('structMap=[\n')
        level += 1
        for structMap_ in self.structMap:
            showIndent(outfile, level)
            outfile.write('model_.structMapType(\n')
            structMap_.exportLiteral(outfile, level, name_='structMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.structLink is not None:
            showIndent(outfile, level)
            outfile.write('structLink=model_.structLinkType1(\n')
            self.structLink.exportLiteral(outfile, level, name_='structLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('behaviorSec=[\n')
        level += 1
        for behaviorSec_ in self.behaviorSec:
            showIndent(outfile, level)
            outfile.write('model_.behaviorSecType(\n')
            behaviorSec_.exportLiteral(outfile, level, name_='behaviorSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PROFILE', node)
        if value is not None and 'PROFILE' not in already_processed:
            already_processed.append('PROFILE')
            self.PROFILE = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('OBJID', node)
        if value is not None and 'OBJID' not in already_processed:
            already_processed.append('OBJID')
            self.OBJID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metsHdr':
            obj_ = metsHdrType.factory()
            obj_.build(child_)
            self.set_metsHdr(obj_)
        elif nodeName_ == 'dmdSec':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.dmdSec.append(obj_)
        elif nodeName_ == 'amdSec':
            obj_ = amdSecType.factory()
            obj_.build(child_)
            self.amdSec.append(obj_)
        elif nodeName_ == 'fileSec':
            obj_ = fileSecType.factory()
            obj_.build(child_)
            self.set_fileSec(obj_)
        elif nodeName_ == 'structMap':
            obj_ = structMapType.factory()
            obj_.build(child_)
            self.structMap.append(obj_)
        elif nodeName_ == 'structLink':
            obj_ = structLinkType1.factory()
            obj_.build(child_)
            self.set_structLink(obj_)
        elif nodeName_ == 'behaviorSec':
            obj_ = behaviorSecType.factory()
            obj_.build(child_)
            self.behaviorSec.append(obj_)
# end class metsType


class amdSecType(GeneratedsSuper):
    """amdSecType: Complex Type for Administrative Metadata Sections The
    administrative metadata section consists of four possible
    subsidiary sections: techMD (technical metadata for
    text/image/audio/video files), rightsMD (intellectual property
    rights metadata), sourceMD (analog/digital source metadata), and
    digiprovMD (digital provenance metadata, that is, the history of
    migrations/translations performed on a digital library object
    from it's original digital capture/encoding). ID (ID/O): This
    attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    Changed use from optional to mandatory, Karin Bredenberg"""
    subclass = None
    superclass = None
    def __init__(self, ID=None, techMD=None, rightsMD=None, sourceMD=None, digiprovMD=None):
        self.ID = _cast(None, ID)
        if techMD is None:
            self.techMD = []
        else:
            self.techMD = techMD
        if rightsMD is None:
            self.rightsMD = []
        else:
            self.rightsMD = rightsMD
        if sourceMD is None:
            self.sourceMD = []
        else:
            self.sourceMD = sourceMD
        if digiprovMD is None:
            self.digiprovMD = []
        else:
            self.digiprovMD = digiprovMD
    def factory(*args_, **kwargs_):
        if amdSecType.subclass:
            return amdSecType.subclass(*args_, **kwargs_)
        else:
            return amdSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_techMD(self): return self.techMD
    def set_techMD(self, techMD): self.techMD = techMD
    def add_techMD(self, value): self.techMD.append(value)
    def insert_techMD(self, index, value): self.techMD[index] = value
    def get_rightsMD(self): return self.rightsMD
    def set_rightsMD(self, rightsMD): self.rightsMD = rightsMD
    def add_rightsMD(self, value): self.rightsMD.append(value)
    def insert_rightsMD(self, index, value): self.rightsMD[index] = value
    def get_sourceMD(self): return self.sourceMD
    def set_sourceMD(self, sourceMD): self.sourceMD = sourceMD
    def add_sourceMD(self, value): self.sourceMD.append(value)
    def insert_sourceMD(self, index, value): self.sourceMD[index] = value
    def get_digiprovMD(self): return self.digiprovMD
    def set_digiprovMD(self, digiprovMD): self.digiprovMD = digiprovMD
    def add_digiprovMD(self, value): self.digiprovMD.append(value)
    def insert_digiprovMD(self, index, value): self.digiprovMD[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='amdSecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='amdSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='amdSecType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='amdSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for techMD_ in self.techMD:
            techMD_.export(outfile, level, namespace_, name_='techMD', pretty_print=pretty_print)
        for rightsMD_ in self.rightsMD:
            rightsMD_.export(outfile, level, namespace_, name_='rightsMD', pretty_print=pretty_print)
        for sourceMD_ in self.sourceMD:
            sourceMD_.export(outfile, level, namespace_, name_='sourceMD', pretty_print=pretty_print)
        for digiprovMD_ in self.digiprovMD:
            digiprovMD_.export(outfile, level, namespace_, name_='digiprovMD', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.techMD or
            self.rightsMD or
            self.sourceMD or
            self.digiprovMD
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='amdSecType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('techMD=[\n')
        level += 1
        for techMD_ in self.techMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            techMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rightsMD=[\n')
        level += 1
        for rightsMD_ in self.rightsMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            rightsMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sourceMD=[\n')
        level += 1
        for sourceMD_ in self.sourceMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            sourceMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('digiprovMD=[\n')
        level += 1
        for digiprovMD_ in self.digiprovMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            digiprovMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'techMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.techMD.append(obj_)
        elif nodeName_ == 'rightsMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.rightsMD.append(obj_)
        elif nodeName_ == 'sourceMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.sourceMD.append(obj_)
        elif nodeName_ == 'digiprovMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.digiprovMD.append(obj_)
# end class amdSecType


class fileGrpType(GeneratedsSuper):
    """fileGrpType: Complex Type for File Groups The file group is used to
    cluster all of the digital files composing a digital library
    object in a hierarchical arrangement (fileGrp is recursively
    defined to enable the creation of the hierarchy). Any file group
    may contain zero or more file elements. File elements in turn
    can contain one or more FLocat elements (a pointer to a file
    containing content for this object) and/or a FContent element
    (the contents of the file, in either XML or Base64 encoding). ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    VERSDATE (dateTime/O): An optional dateTime attribute specifying
    the date this version/fileGrp of the digital object was created.
    ADMID (IDREF/O): Contains the ID attribute values of the
    <techMD>, <sourceMD>, <rightsMD> and/or <digiprovMD> elements
    within the <amdSec> of the METS document applicable to all of
    the files in a particular file group. For more information on
    using METS IDREFS and IDREF type attributes for internal
    linking, see Chapter 4 of the METS Primer. USE (string/O): A
    tagging attribute to indicate the intended use of files within
    this file group (e.g., master, reference, thumbnails for image
    files). A USE attribute can be expressed at the<fileGrp> level,
    the <file> level, the <FLocat> level and/or the <FContent>
    level. A USE attribute value at the <fileGrp> level should
    pertain to all of the files in the <fileGrp>. A USE attribute at
    the <file> level should pertain to all copies of the file as
    represented by subsidiary <FLocat> and/or <FContent> elements. A
    USE attribute at the <FLocat> or <FContent> level pertains to
    the particular copy of the file that is either referenced
    (<FLocat>) or wrapped (<FContent>)."""
    subclass = None
    superclass = None
    def __init__(self, VERSDATE=None, ADMID=None, ID=None, USE=None, fileGrp=None, file=None, extensiontype_=None):
        self.VERSDATE = _cast(None, VERSDATE)
        self.ADMID = _cast(None, ADMID)
        self.ID = _cast(None, ID)
        self.USE = _cast(None, USE)
        if fileGrp is None:
            self.fileGrp = []
        else:
            self.fileGrp = fileGrp
        if file is None:
            self.file = []
        else:
            self.file = file
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if fileGrpType.subclass:
            return fileGrpType.subclass(*args_, **kwargs_)
        else:
            return fileGrpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileGrp(self): return self.fileGrp
    def set_fileGrp(self, fileGrp): self.fileGrp = fileGrp
    def add_fileGrp(self, value): self.fileGrp.append(value)
    def insert_fileGrp(self, index, value): self.fileGrp[index] = value
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def add_file(self, value): self.file.append(value)
    def insert_file(self, index, value): self.file[index] = value
    def get_VERSDATE(self): return self.VERSDATE
    def set_VERSDATE(self, VERSDATE): self.VERSDATE = VERSDATE
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_USE(self): return self.USE
    def set_USE(self, USE): self.USE = USE
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='fileGrpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileGrpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fileGrpType'):
        if self.VERSDATE is not None and 'VERSDATE' not in already_processed:
            already_processed.append('VERSDATE')
            outfile.write(' VERSDATE=%s' % (self.gds_format_string(quote_attrib(self.VERSDATE).encode(ExternalEncoding), input_name='VERSDATE'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s' % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding), input_name='USE'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='fileGrpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileGrp_ in self.fileGrp:
            fileGrp_.export(outfile, level, namespace_, name_='fileGrp', pretty_print=pretty_print)
        for file_ in self.file:
            file_.export(outfile, level, namespace_, name_='file', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.fileGrp or
            self.file
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileGrpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VERSDATE is not None and 'VERSDATE' not in already_processed:
            already_processed.append('VERSDATE')
            showIndent(outfile, level)
            outfile.write('VERSDATE = "%s",\n' % (self.VERSDATE,))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('fileGrp=[\n')
        level += 1
        for fileGrp_ in self.fileGrp:
            showIndent(outfile, level)
            outfile.write('model_.fileGrpType(\n')
            fileGrp_.exportLiteral(outfile, level, name_='fileGrpType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('model_.fileType(\n')
            file_.exportLiteral(outfile, level, name_='fileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('VERSDATE', node)
        if value is not None and 'VERSDATE' not in already_processed:
            already_processed.append('VERSDATE')
            self.VERSDATE = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileGrp':
            class_obj_ = self.get_class_obj_(child_, fileGrpType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.fileGrp.append(obj_)
        elif nodeName_ == 'file':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.file.append(obj_)
# end class fileGrpType


class structMapType(GeneratedsSuper):
    """structMapType: Complex Type for Structural Maps The structural map
    (structMap) outlines a hierarchical structure for the original
    object being encoded, using a series of nested div elements. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    TYPE (string/O): Identifies the type of structure represented by
    the <structMap>. For example, a <structMap> that represented a
    purely logical or intellectual structure could be assigned a
    TYPE value of “logical” whereas a <structMap> that
    represented a purely physical structure could be assigned a TYPE
    value of “physical”. However, the METS schema neither
    defines nor requires a common vocabulary for this attribute. A
    METS profile, however, may well constrain the values for the
    <structMap> TYPE. LABEL (string/O): Describes the <structMap> to
    viewers of the METS document. This would be useful primarily
    where more than one <structMap> is provided for a single object.
    A descriptive LABEL value, in that case, could clarify to users
    the purpose of each of the available structMaps."""
    subclass = None
    superclass = None
    def __init__(self, TYPE=None, ID=None, LABEL=None, div=None):
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.LABEL = _cast(None, LABEL)
        self.div = div
    def factory(*args_, **kwargs_):
        if structMapType.subclass:
            return structMapType.subclass(*args_, **kwargs_)
        else:
            return structMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_div(self): return self.div
    def set_div(self, div): self.div = div
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def export(self, outfile, level, namespace_='', name_='structMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='structMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='structMapType'):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='structMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.div is not None:
            self.div.export(outfile, level, namespace_, name_='div', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.div is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structMapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.div is not None:
            showIndent(outfile, level)
            outfile.write('div=model_.divType(\n')
            self.div.exportLiteral(outfile, level, name_='div')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'div':
            obj_ = divType.factory()
            obj_.build(child_)
            self.set_div(obj_)
# end class structMapType


class divType(GeneratedsSuper):
    """divType: Complex Type for Divisions The METS standard represents a
    document structurally as a series of nested div elements, that
    is, as a hierarchy (e.g., a book, which is composed of chapters,
    which are composed of subchapters, which are composed of text).
    Every div node in the structural map hierarchy may be connected
    (via subsidiary mptr or fptr elements) to content files which
    represent that div's portion of the whole document. SPECIAL NOTE
    REGARDING DIV ATTRIBUTE VALUES: to clarify the differences
    between the ORDER, ORDERLABEL, and LABEL attributes for the
    <div> element, imagine a text with 10 roman numbered pages
    followed by 10 arabic numbered pages. Page iii would have an
    ORDER of "3", an ORDERLABEL of "iii" and a LABEL of "Page iii",
    while page 3 would have an ORDER of "13", an ORDERLABEL of "3"
    and a LABEL of "Page 3". ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. ORDER (integer/O): A
    representation of the div's order among its siblings (e.g., its
    absolute, numeric sequence). For an example, and clarification
    of the distinction between ORDER and ORDERLABEL, see the
    description of the ORDERLABEL attribute. ORDERLABEL (string/O):
    A representation of the div's order among its siblings (e.g.,
    “xii”), or of any non-integer native numbering system. It is
    presumed that this value will still be machine actionable (e.g.,
    it would support ‘go to page ___’ function), and it should
    not be used as a replacement/substitute for the LABEL attribute.
    To understand the differences between ORDER, ORDERLABEL and
    LABEL, imagine a text with 10 roman numbered pages followed by
    10 arabic numbered pages. Page iii would have an ORDER of
    “3”, an ORDERLABEL of “iii” and a LABEL of “Page
    iii”, while page 3 would have an ORDER of “13”, an
    ORDERLABEL of “3” and a LABEL of “Page 3”. LABEL
    (string/O): An attribute used, for example, to identify a <div>
    to an end user viewing the document. Thus a hierarchical
    arrangement of the <div> LABEL values could provide a table of
    contents to the digital content represented by a METS document
    and facilitate the users’ navigation of the digital object.
    Note that a <div> LABEL should be specific to its level in the
    structural map. In the case of a book with chapters, the book
    <div> LABEL should have the book title and the chapter <div>;
    LABELs should have the individual chapter titles, rather than
    having the chapter <div> LABELs combine both book title and
    chapter title . For further of the distinction between LABEL and
    ORDERLABEL see the description of the ORDERLABEL attribute.
    DMDID (IDREFS/O): Contains the ID attribute values identifying
    the <dmdSec>, elements in the METS document that contain or link
    to descriptive metadata pertaining to the structural division
    represented by the current <div> element. For more information
    on using METS IDREFS and IDREF type attributes for internal
    linking, see Chapter 4 of the METS Primer. ADMID (IDREFS/O):
    Contains the ID attribute values identifying the <rightsMD>,
    <sourceMD>, <techMD> and/or <digiprovMD> elements within the
    <amdSec> of the METS document that contain or link to
    administrative metadata pertaining to the structural division
    represented by the <div> element. Typically the <div> ADMID
    attribute would be used to identify the <rightsMD> element or
    elements that pertain to the <div>, but it could be used anytime
    there was a need to link a <div> with pertinent administrative
    metadata. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS
    Primer. TYPE (string/O): An attribute that specifies the type of
    structural division that the <div> element represents. Possible
    <div> TYPE attribute values include: chapter, article, page,
    track, segment, section etc. METS places no constraints on the
    possible TYPE values. Suggestions for controlled vocabularies
    for TYPE may be found on the METS website. CONTENTIDS (URI/O):
    Content IDs for the content represented by the <div> (equivalent
    to DIDL DII or Digital Item Identifier, a unique external ID).
    xlink:label - an xlink label to be referred to by an smLink
    element"""
    subclass = None
    superclass = None
    def __init__(self, ADMID=None, TYPE=None, LABEL=None, DMDID=None, ORDERLABEL=None, CONTENTIDS=None, label=None, ORDER=None, ID=None, mptr=None, fptr=None, div=None):
        self.ADMID = _cast(None, ADMID)
        self.TYPE = _cast(None, TYPE)
        self.LABEL = _cast(None, LABEL)
        self.DMDID = _cast(None, DMDID)
        self.ORDERLABEL = _cast(None, ORDERLABEL)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.label = _cast(None, label)
        self.ORDER = _cast(int, ORDER)
        self.ID = _cast(None, ID)
        if mptr is None:
            self.mptr = []
        else:
            self.mptr = mptr
        if fptr is None:
            self.fptr = []
        else:
            self.fptr = fptr
        if div is None:
            self.div = []
        else:
            self.div = div
    def factory(*args_, **kwargs_):
        if divType.subclass:
            return divType.subclass(*args_, **kwargs_)
        else:
            return divType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mptr(self): return self.mptr
    def set_mptr(self, mptr): self.mptr = mptr
    def add_mptr(self, value): self.mptr.append(value)
    def insert_mptr(self, index, value): self.mptr[index] = value
    def get_fptr(self): return self.fptr
    def set_fptr(self, fptr): self.fptr = fptr
    def add_fptr(self, value): self.fptr.append(value)
    def insert_fptr(self, index, value): self.fptr[index] = value
    def get_div(self): return self.div
    def set_div(self, div): self.div = div
    def add_div(self, value): self.div.append(value)
    def insert_div(self, index, value): self.div[index] = value
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_DMDID(self): return self.DMDID
    def set_DMDID(self, DMDID): self.DMDID = DMDID
    def get_ORDERLABEL(self): return self.ORDERLABEL
    def set_ORDERLABEL(self, ORDERLABEL): self.ORDERLABEL = ORDERLABEL
    def get_CONTENTIDS(self): return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS): self.CONTENTIDS = CONTENTIDS
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_ORDER(self): return self.ORDER
    def set_ORDER(self, ORDER): self.ORDER = ORDER
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='divType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='divType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='divType'):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            outfile.write(' DMDID=%s' % (self.gds_format_string(quote_attrib(self.DMDID).encode(ExternalEncoding), input_name='DMDID'), ))
        if self.ORDERLABEL is not None and 'ORDERLABEL' not in already_processed:
            already_processed.append('ORDERLABEL')
            outfile.write(' ORDERLABEL=%s' % (self.gds_format_string(quote_attrib(self.ORDERLABEL).encode(ExternalEncoding), input_name='ORDERLABEL'), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (quote_attrib(self.CONTENTIDS), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.append('ORDER')
            outfile.write(' ORDER="%s"' % self.gds_format_integer(self.ORDER, input_name='ORDER'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='divType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mptr_ in self.mptr:
            mptr_.export(outfile, level, namespace_, name_='mptr', pretty_print=pretty_print)
        for fptr_ in self.fptr:
            fptr_.export(outfile, level, namespace_, name_='fptr', pretty_print=pretty_print)
        for div_ in self.div:
            div_.export(outfile, level, namespace_, name_='div', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.mptr or
            self.fptr or
            self.div
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='divType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            showIndent(outfile, level)
            outfile.write('DMDID = "%s",\n' % (self.DMDID,))
        if self.ORDERLABEL is not None and 'ORDERLABEL' not in already_processed:
            already_processed.append('ORDERLABEL')
            showIndent(outfile, level)
            outfile.write('ORDERLABEL = "%s",\n' % (self.ORDERLABEL,))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.append('ORDER')
            showIndent(outfile, level)
            outfile.write('ORDER = %d,\n' % (self.ORDER,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mptr=[\n')
        level += 1
        for mptr_ in self.mptr:
            showIndent(outfile, level)
            outfile.write('model_.mptrType(\n')
            mptr_.exportLiteral(outfile, level, name_='mptrType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('fptr=[\n')
        level += 1
        for fptr_ in self.fptr:
            showIndent(outfile, level)
            outfile.write('model_.fptrType(\n')
            fptr_.exportLiteral(outfile, level, name_='fptrType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('div=[\n')
        level += 1
        for div_ in self.div:
            showIndent(outfile, level)
            outfile.write('model_.divType(\n')
            div_.exportLiteral(outfile, level, name_='divType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('DMDID', node)
        if value is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            self.DMDID = value
        value = find_attr_value_('ORDERLABEL', node)
        if value is not None and 'ORDERLABEL' not in already_processed:
            already_processed.append('ORDERLABEL')
            self.ORDERLABEL = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('ORDER', node)
        if value is not None and 'ORDER' not in already_processed:
            already_processed.append('ORDER')
            try:
                self.ORDER = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mptr':
            obj_ = mptrType.factory()
            obj_.build(child_)
            self.mptr.append(obj_)
        elif nodeName_ == 'fptr':
            obj_ = fptrType.factory()
            obj_.build(child_)
            self.fptr.append(obj_)
        elif nodeName_ == 'div':
            obj_ = divType.factory()
            obj_.build(child_)
            self.div.append(obj_)
# end class divType


class parType(GeneratedsSuper):
    """parType: Complex Type for Parallel Files The <par> or parallel files
    element aggregates pointers to files, parts of files, and/or
    sequences of files or parts of files that must be played or
    displayed simultaneously to manifest a block of digital content
    represented by an <fptr> element. ID (ID/O): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external
    linking see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, area=None, seq=None):
        self.ID = _cast(None, ID)
        if area is None:
            self.area = []
        else:
            self.area = area
        if seq is None:
            self.seq = []
        else:
            self.seq = seq
    def factory(*args_, **kwargs_):
        if parType.subclass:
            return parType.subclass(*args_, **kwargs_)
        else:
            return parType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def add_area(self, value): self.area.append(value)
    def insert_area(self, index, value): self.area[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def add_seq(self, value): self.seq.append(value)
    def insert_seq(self, index, value): self.seq[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='parType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='parType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='parType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for area_ in self.area:
            area_.export(outfile, level, namespace_, name_='area', pretty_print=pretty_print)
        for seq_ in self.seq:
            seq_.export(outfile, level, namespace_, name_='seq', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.area or
            self.seq
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='parType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('area=[\n')
        level += 1
        for area_ in self.area:
            showIndent(outfile, level)
            outfile.write('model_.areaType(\n')
            area_.exportLiteral(outfile, level, name_='areaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('seq=[\n')
        level += 1
        for seq_ in self.seq:
            showIndent(outfile, level)
            outfile.write('model_.seqType(\n')
            seq_.exportLiteral(outfile, level, name_='seqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            obj_ = areaType.factory()
            obj_.build(child_)
            self.area.append(obj_)
        elif nodeName_ == 'seq':
            obj_ = seqType.factory()
            obj_.build(child_)
            self.seq.append(obj_)
# end class parType


class seqType(GeneratedsSuper):
    """seqType: Complex Type for Sequences of Files The seq element should
    be used to link a div to a set of content files when those files
    should be played/displayed sequentially to deliver content to a
    user. Individual <area> subelements within the seq element
    provide the links to the files or portions thereof. ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, area=None, par=None):
        self.ID = _cast(None, ID)
        if area is None:
            self.area = []
        else:
            self.area = area
        if par is None:
            self.par = []
        else:
            self.par = par
    def factory(*args_, **kwargs_):
        if seqType.subclass:
            return seqType.subclass(*args_, **kwargs_)
        else:
            return seqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def add_area(self, value): self.area.append(value)
    def insert_area(self, index, value): self.area[index] = value
    def get_par(self): return self.par
    def set_par(self, par): self.par = par
    def add_par(self, value): self.par.append(value)
    def insert_par(self, index, value): self.par[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='seqType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='seqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='seqType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='seqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for area_ in self.area:
            area_.export(outfile, level, namespace_, name_='area', pretty_print=pretty_print)
        for par_ in self.par:
            par_.export(outfile, level, namespace_, name_='par', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.area or
            self.par
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='seqType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('area=[\n')
        level += 1
        for area_ in self.area:
            showIndent(outfile, level)
            outfile.write('model_.areaType(\n')
            area_.exportLiteral(outfile, level, name_='areaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('par=[\n')
        level += 1
        for par_ in self.par:
            showIndent(outfile, level)
            outfile.write('model_.parType(\n')
            par_.exportLiteral(outfile, level, name_='parType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            obj_ = areaType.factory()
            obj_.build(child_)
            self.area.append(obj_)
        elif nodeName_ == 'par':
            obj_ = parType.factory()
            obj_.build(child_)
            self.par.append(obj_)
# end class seqType


class areaType(GeneratedsSuper):
    """areaType: Complex Type for Area Linking The area element provides
    for more sophisticated linking between a div element and content
    files representing that div, be they text, image, audio, or
    video files. An area element can link a div to a point within a
    file, to a one-dimension segment of a file (e.g., text segment,
    image line, audio/video clip), or a two-dimensional section of a
    file (e.g, subsection of an image, or a subsection of the video
    display of a video file. The area element has no content; all
    information is recorded within its various attributes. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    FILEID (IDREF/R): An attribute which provides the XML ID value
    that identifies the <file> element in the <fileSec> that then
    points to and/or contains the digital content represented by the
    <area> element. It must contain an ID value represented in an ID
    attribute associated with a <file> element in the <fileSec>
    element in the same METS document. SHAPE (string/O): An
    attribute that can be used as in HTML to define the shape of the
    relevant area within the content file pointed to by the <area>
    element. Typically this would be used with image content (still
    image or video frame) when only a portion of an integal image
    map pertains. If SHAPE is specified then COORDS must also be
    present. SHAPE should be used in conjunction with COORDS in the
    manner defined for the shape and coords attributes on an HTML4
    <area> element. SHAPE must contain one of the following values:
    RECT CIRCLE POLY COORDS (string/O): Specifies the coordinates in
    an image map for the shape of the pertinent area as specified in
    the SHAPE attribute. While technically optional, SHAPE and
    COORDS must both appear together to define the relevant area of
    image content. COORDS should be used in conjunction with SHAPE
    in the manner defined for the COORDs and SHAPE attributes on an
    HTML4 <area> element. COORDS must be a comma delimited string of
    integer value pairs representing coordinates (plus radius in the
    case of CIRCLE) within an image map. Number of coordinates pairs
    depends on shape: RECT: x1, y1, x2, y2; CIRC: x1, y1; POLY: x1,
    y1, x2, y2, x3, y3 . . . BEGIN (string/O): An attribute that
    specifies the point in the content file where the relevant
    section of content begins. It can be used in conjunction with
    either the END attribute or the EXTENT attribute as a means of
    defining the relevant portion of the referenced file precisely.
    It can only be interpreted meaningfully in conjunction with the
    BETYPE or EXTTYPE, which specify the kind of beginning/ending
    point values or beginning/extent values that are being used. The
    BEGIN attribute can be used with or without a companion END or
    EXTENT element. In this case, the end of the content file is
    assumed to be the end point. END (string/O): An attribute that
    specifies the point in the content file where the relevant
    section of content ends. It can only be interpreted meaningfully
    in conjunction with the BETYPE, which specifies the kind of
    ending point values being used. Typically the END attribute
    would only appear in conjunction with a BEGIN element. BETYPE:
    Begin/End Type. BETYPE (string/O): An attribute that specifies
    the kind of BEGIN and/or END values that are being used. For
    example, if BYTE is specified, then the BEGIN and END point
    values represent the byte offsets into a file. If IDREF is
    specified, then the BEGIN element specifies the ID value that
    identifies the element in a structured text file where the
    relevant section of the file begins; and the END value (if
    present) would specify the ID value that identifies the element
    with which the relevant section of the file ends. Must be one of
    the following values: BYTE IDREF SMIL MIDI SMPTE-25 SMPTE-24
    SMPTE-DF30 SMPTE-NDF30 SMPTE-DF29.97 SMPTE-NDF29.97 TIME TCF
    XPTR EXTENT (string/O): An attribute that specifies the extent
    of the relevant section of the content file. Can only be
    interpreted meaningfully in conjunction with the EXTTYPE which
    specifies the kind of value that is being used. Typically the
    EXTENT attribute would only appear in conjunction with a BEGIN
    element and would not be used if the BEGIN point represents an
    IDREF. EXTTYPE (string/O): An attribute that specifies the kind
    of EXTENT values that are being used. For example if BYTE is
    specified then EXTENT would represent a byte count. If TIME is
    specified the EXTENT would represent a duration of time. EXTTYPE
    must be one of the following values: BYTE SMIL MIDI SMPTE-25
    SMPTE-24 SMPTE-DF30 SMPTE-NDF30 SMPTE-DF29.97 SMPTE-NDF29.97
    TIME TCF. ADMID (IDREFS/O): Contains the ID attribute values
    identifying the <rightsMD>, <sourceMD>, <techMD> and/or
    <digiprovMD> elements within the <amdSec> of the METS document
    that contain or link to administrative metadata pertaining to
    the content represented by the <area> element. Typically the
    <area> ADMID attribute would be used to identify the <rightsMD>
    element or elements that pertain to the <area>, but it could be
    used anytime there was a need to link an <area> with pertinent
    administrative metadata. For more information on using METS
    IDREFS and IDREF type attributes for internal linking, see
    Chapter 4 of the METS Primer CONTENTIDS (URI/O): Content IDs for
    the content represented by the <area> (equivalent to DIDL DII or
    Digital Item Identifier, a unique external ID)."""
    subclass = None
    superclass = None
    def __init__(self, BEGIN=None, END=None, BETYPE=None, SHAPE=None, COORDS=None, EXTENT=None, CONTENTIDS=None, ADMID=None, ID=None, EXTTYPE=None, FILEID=None):
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.BETYPE = _cast(None, BETYPE)
        self.SHAPE = _cast(None, SHAPE)
        self.COORDS = _cast(None, COORDS)
        self.EXTENT = _cast(None, EXTENT)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.ADMID = _cast(None, ADMID)
        self.ID = _cast(None, ID)
        self.EXTTYPE = _cast(None, EXTTYPE)
        self.FILEID = _cast(None, FILEID)
        pass
    def factory(*args_, **kwargs_):
        if areaType.subclass:
            return areaType.subclass(*args_, **kwargs_)
        else:
            return areaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BEGIN(self): return self.BEGIN
    def set_BEGIN(self, BEGIN): self.BEGIN = BEGIN
    def get_END(self): return self.END
    def set_END(self, END): self.END = END
    def get_BETYPE(self): return self.BETYPE
    def set_BETYPE(self, BETYPE): self.BETYPE = BETYPE
    def get_SHAPE(self): return self.SHAPE
    def set_SHAPE(self, SHAPE): self.SHAPE = SHAPE
    def get_COORDS(self): return self.COORDS
    def set_COORDS(self, COORDS): self.COORDS = COORDS
    def get_EXTENT(self): return self.EXTENT
    def set_EXTENT(self, EXTENT): self.EXTENT = EXTENT
    def get_CONTENTIDS(self): return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS): self.CONTENTIDS = CONTENTIDS
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_EXTTYPE(self): return self.EXTTYPE
    def set_EXTTYPE(self, EXTTYPE): self.EXTTYPE = EXTTYPE
    def get_FILEID(self): return self.FILEID
    def set_FILEID(self, FILEID): self.FILEID = FILEID
    def export(self, outfile, level, namespace_='', name_='areaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='areaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='areaType'):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            outfile.write(' BEGIN=%s' % (self.gds_format_string(quote_attrib(self.BEGIN).encode(ExternalEncoding), input_name='BEGIN'), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            outfile.write(' END=%s' % (self.gds_format_string(quote_attrib(self.END).encode(ExternalEncoding), input_name='END'), ))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            outfile.write(' BETYPE=%s' % (self.gds_format_string(quote_attrib(self.BETYPE).encode(ExternalEncoding), input_name='BETYPE'), ))
        if self.SHAPE is not None and 'SHAPE' not in already_processed:
            already_processed.append('SHAPE')
            outfile.write(' SHAPE=%s' % (self.gds_format_string(quote_attrib(self.SHAPE).encode(ExternalEncoding), input_name='SHAPE'), ))
        if self.COORDS is not None and 'COORDS' not in already_processed:
            already_processed.append('COORDS')
            outfile.write(' COORDS=%s' % (self.gds_format_string(quote_attrib(self.COORDS).encode(ExternalEncoding), input_name='COORDS'), ))
        if self.EXTENT is not None and 'EXTENT' not in already_processed:
            already_processed.append('EXTENT')
            outfile.write(' EXTENT=%s' % (self.gds_format_string(quote_attrib(self.EXTENT).encode(ExternalEncoding), input_name='EXTENT'), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (quote_attrib(self.CONTENTIDS), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.EXTTYPE is not None and 'EXTTYPE' not in already_processed:
            already_processed.append('EXTTYPE')
            outfile.write(' EXTTYPE=%s' % (self.gds_format_string(quote_attrib(self.EXTTYPE).encode(ExternalEncoding), input_name='EXTTYPE'), ))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            outfile.write(' FILEID=%s' % (self.gds_format_string(quote_attrib(self.FILEID).encode(ExternalEncoding), input_name='FILEID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='areaType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='areaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            showIndent(outfile, level)
            outfile.write('BEGIN = "%s",\n' % (self.BEGIN,))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            showIndent(outfile, level)
            outfile.write('END = "%s",\n' % (self.END,))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            showIndent(outfile, level)
            outfile.write('BETYPE = "%s",\n' % (self.BETYPE,))
        if self.SHAPE is not None and 'SHAPE' not in already_processed:
            already_processed.append('SHAPE')
            showIndent(outfile, level)
            outfile.write('SHAPE = "%s",\n' % (self.SHAPE,))
        if self.COORDS is not None and 'COORDS' not in already_processed:
            already_processed.append('COORDS')
            showIndent(outfile, level)
            outfile.write('COORDS = "%s",\n' % (self.COORDS,))
        if self.EXTENT is not None and 'EXTENT' not in already_processed:
            already_processed.append('EXTENT')
            showIndent(outfile, level)
            outfile.write('EXTENT = "%s",\n' % (self.EXTENT,))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS,))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.EXTTYPE is not None and 'EXTTYPE' not in already_processed:
            already_processed.append('EXTTYPE')
            showIndent(outfile, level)
            outfile.write('EXTTYPE = "%s",\n' % (self.EXTTYPE,))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            showIndent(outfile, level)
            outfile.write('FILEID = "%s",\n' % (self.FILEID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BEGIN', node)
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            self.BEGIN = value
        value = find_attr_value_('END', node)
        if value is not None and 'END' not in already_processed:
            already_processed.append('END')
            self.END = value
        value = find_attr_value_('BETYPE', node)
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            self.BETYPE = value
        value = find_attr_value_('SHAPE', node)
        if value is not None and 'SHAPE' not in already_processed:
            already_processed.append('SHAPE')
            self.SHAPE = value
        value = find_attr_value_('COORDS', node)
        if value is not None and 'COORDS' not in already_processed:
            already_processed.append('COORDS')
            self.COORDS = value
        value = find_attr_value_('EXTENT', node)
        if value is not None and 'EXTENT' not in already_processed:
            already_processed.append('EXTENT')
            self.EXTENT = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('EXTTYPE', node)
        if value is not None and 'EXTTYPE' not in already_processed:
            already_processed.append('EXTTYPE')
            self.EXTTYPE = value
        value = find_attr_value_('FILEID', node)
        if value is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            self.FILEID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class areaType


class structLinkType(GeneratedsSuper):
    """structLinkType: Complex Type for Structural Map Linking The
    Structural Map Linking section allows for the specification of
    hyperlinks between different components of a METS structure
    delineated in a structural map. structLink contains a single,
    repeatable element, smLink. Each smLink element indicates a
    hyperlink between two nodes in the structMap. The structMap
    nodes recorded in smLink are identified using their XML ID
    attribute values. ID (ID/O): This attribute uniquely identifies
    the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or
    document via an IDREF or an XPTR. For more information on using
    ID attributes for internal and external linking see Chapter 4 of
    the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, smLink=None, smLinkGrp=None, extensiontype_=None):
        self.ID = _cast(None, ID)
        if smLink is None:
            self.smLink = []
        else:
            self.smLink = smLink
        if smLinkGrp is None:
            self.smLinkGrp = []
        else:
            self.smLinkGrp = smLinkGrp
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if structLinkType.subclass:
            return structLinkType.subclass(*args_, **kwargs_)
        else:
            return structLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_smLink(self): return self.smLink
    def set_smLink(self, smLink): self.smLink = smLink
    def add_smLink(self, value): self.smLink.append(value)
    def insert_smLink(self, index, value): self.smLink[index] = value
    def get_smLinkGrp(self): return self.smLinkGrp
    def set_smLinkGrp(self, smLinkGrp): self.smLinkGrp = smLinkGrp
    def add_smLinkGrp(self, value): self.smLinkGrp.append(value)
    def insert_smLinkGrp(self, index, value): self.smLinkGrp[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='structLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='structLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='structLinkType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='structLinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for smLink_ in self.smLink:
            smLink_.export(outfile, level, namespace_, name_='smLink', pretty_print=pretty_print)
        for smLinkGrp_ in self.smLinkGrp:
            smLinkGrp_.export(outfile, level, namespace_, name_='smLinkGrp', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.smLink or
            self.smLinkGrp
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structLinkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('smLink=[\n')
        level += 1
        for smLink_ in self.smLink:
            showIndent(outfile, level)
            outfile.write('model_.smLinkType(\n')
            smLink_.exportLiteral(outfile, level, name_='smLinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smLinkGrp=[\n')
        level += 1
        for smLinkGrp_ in self.smLinkGrp:
            showIndent(outfile, level)
            outfile.write('model_.smLinkGrpType(\n')
            smLinkGrp_.exportLiteral(outfile, level, name_='smLinkGrpType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'smLink':
            obj_ = smLinkType.factory()
            obj_.build(child_)
            self.smLink.append(obj_)
        elif nodeName_ == 'smLinkGrp':
            obj_ = smLinkGrpType.factory()
            obj_.build(child_)
            self.smLinkGrp.append(obj_)
# end class structLinkType


class behaviorSecType(GeneratedsSuper):
    """behaviorSecType: Complex Type for Behavior Sections Behaviors are
    executable code which can be associated with parts of a METS
    object. The behaviorSec element is used to group individual
    behaviors within a hierarchical structure. Such grouping can be
    useful to organize families of behaviors together or to indicate
    other relationships between particular behaviors. ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    CREATED (dateTime/O): Specifies the date and time of creation
    for the <behaviorSec> LABEL (string/O): A text description of
    the behavior section."""
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, ID=None, CREATED=None, behaviorSec=None, behavior=None):
        self.LABEL = _cast(None, LABEL)
        self.ID = _cast(None, ID)
        self.CREATED = _cast(None, CREATED)
        if behaviorSec is None:
            self.behaviorSec = []
        else:
            self.behaviorSec = behaviorSec
        if behavior is None:
            self.behavior = []
        else:
            self.behavior = behavior
    def factory(*args_, **kwargs_):
        if behaviorSecType.subclass:
            return behaviorSecType.subclass(*args_, **kwargs_)
        else:
            return behaviorSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behaviorSec(self): return self.behaviorSec
    def set_behaviorSec(self, behaviorSec): self.behaviorSec = behaviorSec
    def add_behaviorSec(self, value): self.behaviorSec.append(value)
    def insert_behaviorSec(self, index, value): self.behaviorSec[index] = value
    def get_behavior(self): return self.behavior
    def set_behavior(self, behavior): self.behavior = behavior
    def add_behavior(self, value): self.behavior.append(value)
    def insert_behavior(self, index, value): self.behavior[index] = value
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def export(self, outfile, level, namespace_='', name_='behaviorSecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='behaviorSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='behaviorSecType'):
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s' % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding), input_name='CREATED'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='behaviorSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for behaviorSec_ in self.behaviorSec:
            behaviorSec_.export(outfile, level, namespace_, name_='behaviorSec', pretty_print=pretty_print)
        for behavior_ in self.behavior:
            behavior_.export(outfile, level, namespace_, name_='behavior', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.behaviorSec or
            self.behavior
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='behaviorSecType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('behaviorSec=[\n')
        level += 1
        for behaviorSec_ in self.behaviorSec:
            showIndent(outfile, level)
            outfile.write('model_.behaviorSecType(\n')
            behaviorSec_.exportLiteral(outfile, level, name_='behaviorSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('behavior=[\n')
        level += 1
        for behavior_ in self.behavior:
            showIndent(outfile, level)
            outfile.write('model_.behaviorType(\n')
            behavior_.exportLiteral(outfile, level, name_='behaviorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'behaviorSec':
            obj_ = behaviorSecType.factory()
            obj_.build(child_)
            self.behaviorSec.append(obj_)
        elif nodeName_ == 'behavior':
            obj_ = behaviorType.factory()
            obj_.build(child_)
            self.behavior.append(obj_)
# end class behaviorSecType


class behaviorType(GeneratedsSuper):
    """behaviorType: Complex Type for Behaviors A behavior can be used to
    associate executable behaviors with content in the METS object.
    A behavior element has an interface definition element that
    represents an abstract definition of the set of behaviors
    represented by a particular behavior. A behavior element also
    has an behavior mechanism which is a module of executable code
    that implements and runs the behavior defined abstractly by the
    interface definition. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. In the case of a <behavior>
    element that applies to a <transformFile> element, the ID value
    must be present and would be referenced from the
    transformFile/@TRANSFORMBEHAVIOR attribute. For more information
    on using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. STRUCTID (IDREFS/O): An XML IDREFS
    attribute used to link a <behavior> to one or more <div>
    elements within a <structMap> in the METS document. The content
    to which the STRUCTID points is considered input to the
    executable behavior mechanism defined for the behavior. If the
    <behavior> applies to one or more <div> elements, then the
    STRUCTID attribute must be present. BTYPE (string/O): The
    behavior type provides a means of categorizing the related
    behavior.CREATED (dateTime/O): The dateTime of creation for the
    behavior. LABEL (string/O): A text description of the behavior.
    GROUPID (string/O): An identifier that establishes a
    correspondence between the given behavior and other behaviors,
    typically used to facilitate versions of behaviors. ADMID
    (IDREFS/O): An optional attribute listing the XML ID values of
    administrative metadata sections within the METS document
    pertaining to this behavior."""
    subclass = None
    superclass = None
    def __init__(self, ADMID=None, CREATED=None, STRUCTID=None, LABEL=None, GROUPID=None, BTYPE=None, ID=None, interfaceDef=None, mechanism=None):
        self.ADMID = _cast(None, ADMID)
        self.CREATED = _cast(None, CREATED)
        self.STRUCTID = _cast(None, STRUCTID)
        self.LABEL = _cast(None, LABEL)
        self.GROUPID = _cast(None, GROUPID)
        self.BTYPE = _cast(None, BTYPE)
        self.ID = _cast(None, ID)
        self.interfaceDef = interfaceDef
        self.mechanism = mechanism
    def factory(*args_, **kwargs_):
        if behaviorType.subclass:
            return behaviorType.subclass(*args_, **kwargs_)
        else:
            return behaviorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interfaceDef(self): return self.interfaceDef
    def set_interfaceDef(self, interfaceDef): self.interfaceDef = interfaceDef
    def get_mechanism(self): return self.mechanism
    def set_mechanism(self, mechanism): self.mechanism = mechanism
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def get_STRUCTID(self): return self.STRUCTID
    def set_STRUCTID(self, STRUCTID): self.STRUCTID = STRUCTID
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_GROUPID(self): return self.GROUPID
    def set_GROUPID(self, GROUPID): self.GROUPID = GROUPID
    def get_BTYPE(self): return self.BTYPE
    def set_BTYPE(self, BTYPE): self.BTYPE = BTYPE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='behaviorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='behaviorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='behaviorType'):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s' % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding), input_name='CREATED'), ))
        if self.STRUCTID is not None and 'STRUCTID' not in already_processed:
            already_processed.append('STRUCTID')
            outfile.write(' STRUCTID=%s' % (self.gds_format_string(quote_attrib(self.STRUCTID).encode(ExternalEncoding), input_name='STRUCTID'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            outfile.write(' GROUPID=%s' % (self.gds_format_string(quote_attrib(self.GROUPID).encode(ExternalEncoding), input_name='GROUPID'), ))
        if self.BTYPE is not None and 'BTYPE' not in already_processed:
            already_processed.append('BTYPE')
            outfile.write(' BTYPE=%s' % (self.gds_format_string(quote_attrib(self.BTYPE).encode(ExternalEncoding), input_name='BTYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='behaviorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.interfaceDef is not None:
            self.interfaceDef.export(outfile, level, namespace_, name_='interfaceDef', pretty_print=pretty_print)
        if self.mechanism is not None:
            self.mechanism.export(outfile, level, namespace_, name_='mechanism', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.interfaceDef is not None or
            self.mechanism is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='behaviorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED,))
        if self.STRUCTID is not None and 'STRUCTID' not in already_processed:
            already_processed.append('STRUCTID')
            showIndent(outfile, level)
            outfile.write('STRUCTID = "%s",\n' % (self.STRUCTID,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            showIndent(outfile, level)
            outfile.write('GROUPID = "%s",\n' % (self.GROUPID,))
        if self.BTYPE is not None and 'BTYPE' not in already_processed:
            already_processed.append('BTYPE')
            showIndent(outfile, level)
            outfile.write('BTYPE = "%s",\n' % (self.BTYPE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.interfaceDef is not None:
            showIndent(outfile, level)
            outfile.write('interfaceDef=model_.objectType(\n')
            self.interfaceDef.exportLiteral(outfile, level, name_='interfaceDef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mechanism is not None:
            showIndent(outfile, level)
            outfile.write('mechanism=model_.objectType(\n')
            self.mechanism.exportLiteral(outfile, level, name_='mechanism')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = find_attr_value_('STRUCTID', node)
        if value is not None and 'STRUCTID' not in already_processed:
            already_processed.append('STRUCTID')
            self.STRUCTID = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('GROUPID', node)
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            self.GROUPID = value
        value = find_attr_value_('BTYPE', node)
        if value is not None and 'BTYPE' not in already_processed:
            already_processed.append('BTYPE')
            self.BTYPE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interfaceDef':
            obj_ = objectType.factory()
            obj_.build(child_)
            self.set_interfaceDef(obj_)
        elif nodeName_ == 'mechanism':
            obj_ = objectType.factory()
            obj_.build(child_)
            self.set_mechanism(obj_)
# end class behaviorType


class objectType(GeneratedsSuper):
    """objectType: complexType for interfaceDef and mechanism elements The
    mechanism and behavior elements point to external objects--an
    interface definition object or an executable code object
    respectively--which together constitute a behavior that can be
    applied to one or more <div> elements in a <structMap>. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    LABEL (string/O): A text description of the entity represented."""
    subclass = None
    superclass = None
    def __init__(self, arcrole=None, title=None, OTHERLOCTYPE=None, show=None, actuate=None, LABEL=None, href=None, role=None, LOCTYPE=None, type_=None, ID=None):
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.LABEL = _cast(None, LABEL)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if objectType.subclass:
            return objectType.subclass(*args_, **kwargs_)
        else:
            return objectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_OTHERLOCTYPE(self): return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE): self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_LOCTYPE(self): return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE): self.LOCTYPE = LOCTYPE
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='objectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectType'):
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding), input_name='OTHERLOCTYPE'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding), input_name='LOCTYPE'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='objectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n' % (self.OTHERLOCTYPE,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class objectType


class mdSecType(GeneratedsSuper):
    """mdSecType: Complex Type for Metadata Sections A generic framework
    for pointing to/including metadata within a METS document, a la
    Warwick Framework. ID (ID/R): This attribute uniquely identifies
    the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or
    document via an IDREF or an XPTR. The ID attribute on the
    <dmdSec>, <techMD>, <sourceMD>, <rightsMD> and <digiprovMD>
    elements (which are all of mdSecType) is required, and its value
    should be referenced from one or more DMDID attributes (when the
    ID identifies a <dmdSec> element) or ADMID attributes (when the
    ID identifies a <techMD>, <sourceMD>, <rightsMD> or <digiprovMD>
    element) that are associated with other elements in the METS
    document. The following elements support references to a
    <dmdSec> via a DMDID attribute: <file>, <stream>, <div>. The
    following elements support references to <techMD>, <sourceMD>,
    <rightsMD> and <digiprovMD> elements via an ADMID attribute:
    <metsHdr>, <dmdSec>, <techMD>, <sourceMD>, <rightsMD>,
    <digiprovMD>, <fileGrp>, <file>, <stream>, <div>, <area>,
    <behavior>. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    GROUPID (string/O): This identifier is used to indicate that
    different metadata sections may be considered as part of a
    group. Two metadata sections with the same GROUPID value are to
    be considered part of the same group. For example this facility
    might be used to group changed versions of the same metadata if
    previous versions are maintained in a file for tracking
    purposes. ADMID (IDREFS/O): Contains the ID attribute values of
    the <digiprovMD>, <techMD>, <sourceMD> and/or <rightsMD>
    elements within the <amdSec> of the METS document that contain
    administrative metadata pertaining to the current mdSecType
    element. Typically used in this context to reference
    preservation metadata (digiprovMD) which applies to the current
    metadata. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS
    Primer. CREATED (dateTime/O): Specifies the date and time of
    creation for the metadata. STATUS (string/O): Indicates the
    status of this metadata (e.g., superseded, current, etc.)."""
    subclass = None
    superclass = None
    def __init__(self, STATUS=None, ADMID=None, CREATED=None, ID=None, GROUPID=None, mdRef=None, mdWrap=None):
        self.STATUS = _cast(None, STATUS)
        self.ADMID = _cast(None, ADMID)
        self.CREATED = _cast(None, CREATED)
        self.ID = _cast(None, ID)
        self.GROUPID = _cast(None, GROUPID)
        self.mdRef = mdRef
        self.mdWrap = mdWrap
    def factory(*args_, **kwargs_):
        if mdSecType.subclass:
            return mdSecType.subclass(*args_, **kwargs_)
        else:
            return mdSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mdRef(self): return self.mdRef
    def set_mdRef(self, mdRef): self.mdRef = mdRef
    def get_mdWrap(self): return self.mdWrap
    def set_mdWrap(self, mdWrap): self.mdWrap = mdWrap
    def get_STATUS(self): return self.STATUS
    def set_STATUS(self, STATUS): self.STATUS = STATUS
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_GROUPID(self): return self.GROUPID
    def set_GROUPID(self, GROUPID): self.GROUPID = GROUPID
    def export(self, outfile, level, namespace_='', name_='mdSecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mdSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mdSecType'):
        if self.STATUS is not None and 'STATUS' not in already_processed:
            already_processed.append('STATUS')
            outfile.write(' STATUS=%s' % (self.gds_format_string(quote_attrib(self.STATUS).encode(ExternalEncoding), input_name='STATUS'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s' % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding), input_name='CREATED'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            outfile.write(' GROUPID=%s' % (self.gds_format_string(quote_attrib(self.GROUPID).encode(ExternalEncoding), input_name='GROUPID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mdSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mdRef is not None:
            self.mdRef.export(outfile, level, namespace_, name_='mdRef', pretty_print=pretty_print)
        if self.mdWrap is not None:
            self.mdWrap.export(outfile, level, namespace_, name_='mdWrap', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.mdRef is not None or
            self.mdWrap is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mdSecType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.STATUS is not None and 'STATUS' not in already_processed:
            already_processed.append('STATUS')
            showIndent(outfile, level)
            outfile.write('STATUS = "%s",\n' % (self.STATUS,))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            showIndent(outfile, level)
            outfile.write('GROUPID = "%s",\n' % (self.GROUPID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mdRef is not None:
            showIndent(outfile, level)
            outfile.write('mdRef=model_.mdRefType(\n')
            self.mdRef.exportLiteral(outfile, level, name_='mdRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mdWrap is not None:
            showIndent(outfile, level)
            outfile.write('mdWrap=model_.mdWrapType(\n')
            self.mdWrap.exportLiteral(outfile, level, name_='mdWrap')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('STATUS', node)
        if value is not None and 'STATUS' not in already_processed:
            already_processed.append('STATUS')
            self.STATUS = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('GROUPID', node)
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            self.GROUPID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mdRef':
            obj_ = mdRefType.factory()
            obj_.build(child_)
            self.set_mdRef(obj_)
        elif nodeName_ == 'mdWrap':
            obj_ = mdWrapType.factory()
            obj_.build(child_)
            self.set_mdWrap(obj_)
# end class mdSecType


class fileType(GeneratedsSuper):
    """fileType: Complex Type for Files The file element provides access to
    content files for a METS object. A file element may contain one
    or more FLocat elements, which provide pointers to a content
    file, and/or an FContent element, which wraps an encoded version
    of the file. Note that ALL FLocat and FContent elements
    underneath a single file element should identify/contain
    identical copies of a single file. ID (ID/R): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. Typically,
    the ID attribute value on a <file> element would be referenced
    from one or more FILEID attributes (which are of type IDREF) on
    <fptr>and/or <area> elements within the <structMap>. Such
    references establish links between structural divisions (<div>
    elements) and the specific content files or parts of content
    files that manifest them. For more information on using ID
    attributes for internal and external linking see Chapter 4 of
    the METS Primer. SEQ (integer/O): Indicates the sequence of this
    <file> relative to the others in its <fileGrp>. OWNERID
    (string/O): A unique identifier assigned to the file by its
    owner. This may be a URI which differs from the URI used to
    retrieve the file. ADMID (IDREFS/O): Contains the ID attribute
    values of the <techMD>, <sourceMD>, <rightsMD> and/or
    <digiprovMD> elements within the <amdSec> of the METS document
    that contain administrative metadata pertaining to the file. For
    more information on using METS IDREFS and IDREF type attributes
    for internal linking, see Chapter 4 of the METS Primer. DMDID
    (IDREFS/O): Contains the ID attribute values identifying the
    <dmdSec>, elements in the METS document that contain or link to
    descriptive metadata pertaining to the content file represented
    by the current <file> element. For more information on using
    METS IDREFS and IDREF type attributes for internal linking, see
    Chapter 4 of the METS Primer. GROUPID (string/O): An identifier
    that establishes a correspondence between this file and files in
    other file groups. Typically, this will be used to associate a
    master file in one file group with the derivative files made
    from it in other file groups. USE (string/O): A tagging
    attribute to indicate the intended use of all copies of the file
    aggregated by the <file> element (e.g., master, reference,
    thumbnails for image files). A USE attribute can be expressed at
    the<fileGrp> level, the <file> level, the <FLocat> level and/or
    the <FContent> level. A USE attribute value at the <fileGrp>
    level should pertain to all of the files in the <fileGrp>. A USE
    attribute at the <file> level should pertain to all copies of
    the file as represented by subsidiary <FLocat> and/or <FContent>
    elements. A USE attribute at the <FLocat> or <FContent> level
    pertains to the particular copy of the file that is either
    referenced (<FLocat>) or wrapped (<FContent>). Changed use to
    mandatory. Karin BredenbergBEGIN (string/O): An attribute that
    specifies the point in the parent <file> where the current
    <file> begins. When used in conjunction with a <file> element,
    this attribute is only meaningful when this element is nested,
    and its parent <file> element represents a container file. It
    can be used in conjunction with the END attribute as a means of
    defining the location of the current file within its parent
    file. However, the BEGIN attribute can be used with or without a
    companion END attribute. When no END attribute is specified, the
    end of the parent file is assumed also to be the end point of
    the current file. The BEGIN and END attributes can only be
    interpreted meaningfully in conjunction with a BETYPE attribute,
    which specifies the kind of beginning/ending point values that
    are being used. END (string/O): An attribute that specifies the
    point in the parent <file> where the current, nested <file>
    ends. It can only be interpreted meaningfully in conjunction
    with the BETYPE, which specifies the kind of ending point values
    being used. Typically the END attribute would only appear in
    conjunction with a BEGIN attribute. BETYPE: Begin/End Type.
    BETYPE (string/O): An attribute that specifies the kind of BEGIN
    and/or END values that are being used. Currently BYTE is the
    only valid value that can be used in conjunction with nested
    <file> or <stream> elements."""
    subclass = None
    superclass = None
    def __init__(self, MIMETYPE=None, ADMID=None, END=None, CHECKSUMTYPE=None, SEQ=None, CREATED=None, CHECKSUM=None, USE=None, ID=None, DMDID=None, BEGIN=None, OWNERID=None, SIZE=None, GROUPID=None, BETYPE=None, FLocat=None, FContent=None, stream=None, transformFile=None, file=None):
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.ADMID = _cast(None, ADMID)
        self.END = _cast(None, END)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.SEQ = _cast(int, SEQ)
        self.CREATED = _cast(None, CREATED)
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.USE = _cast(None, USE)
        self.ID = _cast(None, ID)
        self.DMDID = _cast(None, DMDID)
        self.BEGIN = _cast(None, BEGIN)
        self.OWNERID = _cast(None, OWNERID)
        self.SIZE = _cast(int, SIZE)
        self.GROUPID = _cast(None, GROUPID)
        self.BETYPE = _cast(None, BETYPE)
        self.FLocat = FLocat
        self.FContent = FContent
        if stream is None:
            self.stream = []
        else:
            self.stream = stream
        if transformFile is None:
            self.transformFile = []
        else:
            self.transformFile = transformFile
        if file is None:
            self.file = []
        else:
            self.file = file
    def factory(*args_, **kwargs_):
        if fileType.subclass:
            return fileType.subclass(*args_, **kwargs_)
        else:
            return fileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FLocat(self): return self.FLocat
    def set_FLocat(self, FLocat): self.FLocat = FLocat
    def get_FContent(self): return self.FContent
    def set_FContent(self, FContent): self.FContent = FContent
    def get_stream(self): return self.stream
    def set_stream(self, stream): self.stream = stream
    def add_stream(self, value): self.stream.append(value)
    def insert_stream(self, index, value): self.stream[index] = value
    def get_transformFile(self): return self.transformFile
    def set_transformFile(self, transformFile): self.transformFile = transformFile
    def add_transformFile(self, value): self.transformFile.append(value)
    def insert_transformFile(self, index, value): self.transformFile[index] = value
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def add_file(self, value): self.file.append(value)
    def insert_file(self, index, value): self.file[index] = value
    def get_MIMETYPE(self): return self.MIMETYPE
    def set_MIMETYPE(self, MIMETYPE): self.MIMETYPE = MIMETYPE
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_END(self): return self.END
    def set_END(self, END): self.END = END
    def get_CHECKSUMTYPE(self): return self.CHECKSUMTYPE
    def set_CHECKSUMTYPE(self, CHECKSUMTYPE): self.CHECKSUMTYPE = CHECKSUMTYPE
    def get_SEQ(self): return self.SEQ
    def set_SEQ(self, SEQ): self.SEQ = SEQ
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def get_CHECKSUM(self): return self.CHECKSUM
    def set_CHECKSUM(self, CHECKSUM): self.CHECKSUM = CHECKSUM
    def get_USE(self): return self.USE
    def set_USE(self, USE): self.USE = USE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DMDID(self): return self.DMDID
    def set_DMDID(self, DMDID): self.DMDID = DMDID
    def get_BEGIN(self): return self.BEGIN
    def set_BEGIN(self, BEGIN): self.BEGIN = BEGIN
    def get_OWNERID(self): return self.OWNERID
    def set_OWNERID(self, OWNERID): self.OWNERID = OWNERID
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_GROUPID(self): return self.GROUPID
    def set_GROUPID(self, GROUPID): self.GROUPID = GROUPID
    def get_BETYPE(self): return self.BETYPE
    def set_BETYPE(self, BETYPE): self.BETYPE = BETYPE
    def export(self, outfile, level, namespace_='', name_='fileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fileType'):
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            outfile.write(' MIMETYPE=%s' % (self.gds_format_string(quote_attrib(self.MIMETYPE).encode(ExternalEncoding), input_name='MIMETYPE'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            outfile.write(' END=%s' % (self.gds_format_string(quote_attrib(self.END).encode(ExternalEncoding), input_name='END'), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s' % (self.gds_format_string(quote_attrib(self.CHECKSUMTYPE).encode(ExternalEncoding), input_name='CHECKSUMTYPE'), ))
        if self.SEQ is not None and 'SEQ' not in already_processed:
            already_processed.append('SEQ')
            outfile.write(' SEQ="%s"' % self.gds_format_integer(self.SEQ, input_name='SEQ'))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s' % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding), input_name='CREATED'), ))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            outfile.write(' CHECKSUM=%s' % (self.gds_format_string(quote_attrib(self.CHECKSUM).encode(ExternalEncoding), input_name='CHECKSUM'), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s' % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding), input_name='USE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            outfile.write(' DMDID=%s' % (self.gds_format_string(quote_attrib(self.DMDID).encode(ExternalEncoding), input_name='DMDID'), ))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            outfile.write(' BEGIN=%s' % (self.gds_format_string(quote_attrib(self.BEGIN).encode(ExternalEncoding), input_name='BEGIN'), ))
        if self.OWNERID is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            outfile.write(' OWNERID=%s' % (self.gds_format_string(quote_attrib(self.OWNERID).encode(ExternalEncoding), input_name='OWNERID'), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            outfile.write(' GROUPID=%s' % (self.gds_format_string(quote_attrib(self.GROUPID).encode(ExternalEncoding), input_name='GROUPID'), ))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            outfile.write(' BETYPE=%s' % (self.gds_format_string(quote_attrib(self.BETYPE).encode(ExternalEncoding), input_name='BETYPE'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='fileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FLocat is not None:
            self.FLocat.export(outfile, level, namespace_, name_='FLocat', pretty_print=pretty_print)
        if self.FContent is not None:
            self.FContent.export(outfile, level, namespace_, name_='FContent', pretty_print=pretty_print)
        for stream_ in self.stream:
            stream_.export(outfile, level, namespace_, name_='stream', pretty_print=pretty_print)
        for transformFile_ in self.transformFile:
            transformFile_.export(outfile, level, namespace_, name_='transformFile', pretty_print=pretty_print)
        for file_ in self.file:
            file_.export(outfile, level, namespace_, name_='file', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FLocat is not None or
            self.FContent is not None or
            self.stream or
            self.transformFile or
            self.file
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            showIndent(outfile, level)
            outfile.write('MIMETYPE = "%s",\n' % (self.MIMETYPE,))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            showIndent(outfile, level)
            outfile.write('END = "%s",\n' % (self.END,))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            showIndent(outfile, level)
            outfile.write('CHECKSUMTYPE = "%s",\n' % (self.CHECKSUMTYPE,))
        if self.SEQ is not None and 'SEQ' not in already_processed:
            already_processed.append('SEQ')
            showIndent(outfile, level)
            outfile.write('SEQ = %d,\n' % (self.SEQ,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED,))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            showIndent(outfile, level)
            outfile.write('CHECKSUM = "%s",\n' % (self.CHECKSUM,))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            showIndent(outfile, level)
            outfile.write('DMDID = "%s",\n' % (self.DMDID,))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            showIndent(outfile, level)
            outfile.write('BEGIN = "%s",\n' % (self.BEGIN,))
        if self.OWNERID is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            showIndent(outfile, level)
            outfile.write('OWNERID = "%s",\n' % (self.OWNERID,))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE = %d,\n' % (self.SIZE,))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            showIndent(outfile, level)
            outfile.write('GROUPID = "%s",\n' % (self.GROUPID,))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            showIndent(outfile, level)
            outfile.write('BETYPE = "%s",\n' % (self.BETYPE,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FLocat is not None:
            showIndent(outfile, level)
            outfile.write('FLocat=model_.FLocatType(\n')
            self.FLocat.exportLiteral(outfile, level, name_='FLocat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FContent is not None:
            showIndent(outfile, level)
            outfile.write('FContent=model_.FContentType(\n')
            self.FContent.exportLiteral(outfile, level, name_='FContent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stream=[\n')
        level += 1
        for stream_ in self.stream:
            showIndent(outfile, level)
            outfile.write('model_.streamType(\n')
            stream_.exportLiteral(outfile, level, name_='streamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transformFile=[\n')
        level += 1
        for transformFile_ in self.transformFile:
            showIndent(outfile, level)
            outfile.write('model_.transformFileType(\n')
            transformFile_.exportLiteral(outfile, level, name_='transformFileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('model_.fileType(\n')
            file_.exportLiteral(outfile, level, name_='fileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MIMETYPE', node)
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            self.MIMETYPE = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('END', node)
        if value is not None and 'END' not in already_processed:
            already_processed.append('END')
            self.END = value
        value = find_attr_value_('CHECKSUMTYPE', node)
        if value is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        value = find_attr_value_('SEQ', node)
        if value is not None and 'SEQ' not in already_processed:
            already_processed.append('SEQ')
            try:
                self.SEQ = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = find_attr_value_('CHECKSUM', node)
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            self.CHECKSUM = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('DMDID', node)
        if value is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            self.DMDID = value
        value = find_attr_value_('BEGIN', node)
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            self.BEGIN = value
        value = find_attr_value_('OWNERID', node)
        if value is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            self.OWNERID = value
        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('GROUPID', node)
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            self.GROUPID = value
        value = find_attr_value_('BETYPE', node)
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            self.BETYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FLocat':
            obj_ = FLocatType.factory()
            obj_.build(child_)
            self.set_FLocat(obj_)
        elif nodeName_ == 'FContent':
            obj_ = FContentType.factory()
            obj_.build(child_)
            self.set_FContent(obj_)
        elif nodeName_ == 'stream':
            obj_ = streamType.factory()
            obj_.build(child_)
            self.stream.append(obj_)
        elif nodeName_ == 'transformFile':
            obj_ = transformFileType.factory()
            obj_.build(child_)
            self.transformFile.append(obj_)
        elif nodeName_ == 'file':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.file.append(obj_)
# end class fileType


class metsHdrType(GeneratedsSuper):
    """ ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    ADMID (IDREFS/O): Contains the ID attribute values of the
    <techMD>, <sourceMD>, <rightsMD> and/or <digiprovMD> elements
    within the <amdSec> of the METS document that contain
    administrative metadata pertaining to the METS document itself.
    For more information on using METS IDREFS and IDREF type
    attributes for internal linking, see Chapter 4 of the METS
    Primer. CREATEDATE (dateTime/O): Records the date/time the METS
    document was created. Made the attribut mandatory instead of
    optional, Karin BredenbergLASTMODDATE (dateTime/O): Is used to
    indicate the date/time the METS document was last modified.
    RECORDSTATUS (string/O): Specifies the status of the METS
    document. It is used for internal processing purposes. Added
    valuelist, Karin BredenbergRemoved type, Karin Bredenberg
    type="xsd:string" """
    subclass = None
    superclass = None
    def __init__(self, CREATEDATE=None, RECORDSTATUS=None, ADMID=None, LASTMODDATE=None, ID=None, agent=None, altRecordID=None, metsDocumentID=None):
        self.CREATEDATE = _cast(None, CREATEDATE)
        self.RECORDSTATUS = _cast(None, RECORDSTATUS)
        self.ADMID = _cast(None, ADMID)
        self.LASTMODDATE = _cast(None, LASTMODDATE)
        self.ID = _cast(None, ID)
        if agent is None:
            self.agent = []
        else:
            self.agent = agent
        if altRecordID is None:
            self.altRecordID = []
        else:
            self.altRecordID = altRecordID
        self.metsDocumentID = metsDocumentID
    def factory(*args_, **kwargs_):
        if metsHdrType.subclass:
            return metsHdrType.subclass(*args_, **kwargs_)
        else:
            return metsHdrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agent(self): return self.agent
    def set_agent(self, agent): self.agent = agent
    def add_agent(self, value): self.agent.append(value)
    def insert_agent(self, index, value): self.agent[index] = value
    def get_altRecordID(self): return self.altRecordID
    def set_altRecordID(self, altRecordID): self.altRecordID = altRecordID
    def add_altRecordID(self, value): self.altRecordID.append(value)
    def insert_altRecordID(self, index, value): self.altRecordID[index] = value
    def get_metsDocumentID(self): return self.metsDocumentID
    def set_metsDocumentID(self, metsDocumentID): self.metsDocumentID = metsDocumentID
    def get_CREATEDATE(self): return self.CREATEDATE
    def set_CREATEDATE(self, CREATEDATE): self.CREATEDATE = CREATEDATE
    def get_RECORDSTATUS(self): return self.RECORDSTATUS
    def set_RECORDSTATUS(self, RECORDSTATUS): self.RECORDSTATUS = RECORDSTATUS
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_LASTMODDATE(self): return self.LASTMODDATE
    def set_LASTMODDATE(self, LASTMODDATE): self.LASTMODDATE = LASTMODDATE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='metsHdrType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metsHdrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='metsHdrType'):
        if self.CREATEDATE is not None and 'CREATEDATE' not in already_processed:
            already_processed.append('CREATEDATE')
            outfile.write(' CREATEDATE=%s' % (self.gds_format_string(quote_attrib(self.CREATEDATE).encode(ExternalEncoding), input_name='CREATEDATE'), ))
        if self.RECORDSTATUS is not None and 'RECORDSTATUS' not in already_processed:
            already_processed.append('RECORDSTATUS')
            outfile.write(' RECORDSTATUS=%s' % (self.gds_format_string(quote_attrib(self.RECORDSTATUS).encode(ExternalEncoding), input_name='RECORDSTATUS'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.LASTMODDATE is not None and 'LASTMODDATE' not in already_processed:
            already_processed.append('LASTMODDATE')
            outfile.write(' LASTMODDATE=%s' % (self.gds_format_string(quote_attrib(self.LASTMODDATE).encode(ExternalEncoding), input_name='LASTMODDATE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='metsHdrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for agent_ in self.agent:
            agent_.export(outfile, level, namespace_, name_='agent', pretty_print=pretty_print)
        for altRecordID_ in self.altRecordID:
            altRecordID_.export(outfile, level, namespace_, name_='altRecordID', pretty_print=pretty_print)
        if self.metsDocumentID is not None:
            self.metsDocumentID.export(outfile, level, namespace_, name_='metsDocumentID', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.agent or
            self.altRecordID or
            self.metsDocumentID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metsHdrType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CREATEDATE is not None and 'CREATEDATE' not in already_processed:
            already_processed.append('CREATEDATE')
            showIndent(outfile, level)
            outfile.write('CREATEDATE = "%s",\n' % (self.CREATEDATE,))
        if self.RECORDSTATUS is not None and 'RECORDSTATUS' not in already_processed:
            already_processed.append('RECORDSTATUS')
            showIndent(outfile, level)
            outfile.write('RECORDSTATUS = "%s",\n' % (self.RECORDSTATUS,))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.LASTMODDATE is not None and 'LASTMODDATE' not in already_processed:
            already_processed.append('LASTMODDATE')
            showIndent(outfile, level)
            outfile.write('LASTMODDATE = "%s",\n' % (self.LASTMODDATE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('agent=[\n')
        level += 1
        for agent_ in self.agent:
            showIndent(outfile, level)
            outfile.write('model_.agentType(\n')
            agent_.exportLiteral(outfile, level, name_='agentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('altRecordID=[\n')
        level += 1
        for altRecordID_ in self.altRecordID:
            showIndent(outfile, level)
            outfile.write('model_.altRecordIDType(\n')
            altRecordID_.exportLiteral(outfile, level, name_='altRecordIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.metsDocumentID is not None:
            showIndent(outfile, level)
            outfile.write('metsDocumentID=model_.metsDocumentIDType(\n')
            self.metsDocumentID.exportLiteral(outfile, level, name_='metsDocumentID')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CREATEDATE', node)
        if value is not None and 'CREATEDATE' not in already_processed:
            already_processed.append('CREATEDATE')
            self.CREATEDATE = value
        value = find_attr_value_('RECORDSTATUS', node)
        if value is not None and 'RECORDSTATUS' not in already_processed:
            already_processed.append('RECORDSTATUS')
            self.RECORDSTATUS = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('LASTMODDATE', node)
        if value is not None and 'LASTMODDATE' not in already_processed:
            already_processed.append('LASTMODDATE')
            self.LASTMODDATE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agent':
            obj_ = agentType.factory()
            obj_.build(child_)
            self.agent.append(obj_)
        elif nodeName_ == 'altRecordID':
            obj_ = altRecordIDType.factory()
            obj_.build(child_)
            self.altRecordID.append(obj_)
        elif nodeName_ == 'metsDocumentID':
            obj_ = metsDocumentIDType.factory()
            obj_.build(child_)
            self.set_metsDocumentID(obj_)
# end class metsHdrType


class agentType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    ROLE (string/R): Specifies the function of the agent with
    respect to the METS record. The allowed values are: CREATOR: The
    person(s) or institution(s) responsible for the METS document.
    EDITOR: The person(s) or institution(s) that prepares the
    metadata for encoding. ARCHIVIST: The person(s) or
    institution(s) responsible for the document/collection.
    PRESERVATION: The person(s) or institution(s) responsible for
    preservation functions. DISSEMINATOR: The person(s) or
    institution(s) responsible for dissemination functions.
    CUSTODIAN: The person(s) or institution(s) charged with the
    oversight of a document/collection. IPOWNER: Intellectual
    Property Owner: The person(s) or institution holding copyright,
    trade or service marks or other intellectual property rights for
    the object. OTHER: Use OTHER if none of the preceding values
    pertains and clarify the type and location specifier being used
    in the OTHERROLE attribute (see below). OTHERROLE (string/O):
    Denotes a role not contained in the allowed values set if OTHER
    is indicated in the ROLE attribute. TYPE (string/O): is used to
    specify the type of AGENT. It must be one of the following
    values: INDIVIDUAL: Use if an individual has served as the
    agent. ORGANIZATION: Use if an institution, corporate body,
    association, non-profit enterprise, government, religious body,
    etc. has served as the agent. OTHER: Use OTHER if none of the
    preceding values pertain and clarify the type of agent specifier
    being used in the OTHERTYPE attribute Changed use from optional
    to mandatory, Karin BredenbergOTHERTYPE (string/O): Specifies
    the type of agent when the value OTHER is indicated in the TYPE
    attribute. Removed type, Karin Bredenberg type="xsd:string"
    Added valuelist, Karin Bredenberg"""
    subclass = None
    superclass = None
    def __init__(self, TYPE=None, OTHERTYPE=None, ROLE=None, ID=None, OTHERROLE=None, name=None, note=None):
        self.TYPE = _cast(None, TYPE)
        self.OTHERTYPE = _cast(None, OTHERTYPE)
        self.ROLE = _cast(None, ROLE)
        self.ID = _cast(None, ID)
        self.OTHERROLE = _cast(None, OTHERROLE)
        self.name = name
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if agentType.subclass:
            return agentType.subclass(*args_, **kwargs_)
        else:
            return agentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_OTHERTYPE(self): return self.OTHERTYPE
    def set_OTHERTYPE(self, OTHERTYPE): self.OTHERTYPE = OTHERTYPE
    def get_ROLE(self): return self.ROLE
    def set_ROLE(self, ROLE): self.ROLE = ROLE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_OTHERROLE(self): return self.OTHERROLE
    def set_OTHERROLE(self, OTHERROLE): self.OTHERROLE = OTHERROLE
    def export(self, outfile, level, namespace_='', name_='agentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='agentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='agentType'):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
        if self.OTHERTYPE is not None and 'OTHERTYPE' not in already_processed:
            already_processed.append('OTHERTYPE')
            outfile.write(' OTHERTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERTYPE).encode(ExternalEncoding), input_name='OTHERTYPE'), ))
        if self.ROLE is not None and 'ROLE' not in already_processed:
            already_processed.append('ROLE')
            outfile.write(' ROLE=%s' % (self.gds_format_string(quote_attrib(self.ROLE).encode(ExternalEncoding), input_name='ROLE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.OTHERROLE is not None and 'OTHERROLE' not in already_processed:
            already_processed.append('OTHERROLE')
            outfile.write(' OTHERROLE=%s' % (self.gds_format_string(quote_attrib(self.OTHERROLE).encode(ExternalEncoding), input_name='OTHERROLE'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='agentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for note_ in self.note:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snote>%s</%snote>%s' % (namespace_, self.gds_format_string(quote_xml(note_).encode(ExternalEncoding), input_name='note'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='agentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE,))
        if self.OTHERTYPE is not None and 'OTHERTYPE' not in already_processed:
            already_processed.append('OTHERTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERTYPE = "%s",\n' % (self.OTHERTYPE,))
        if self.ROLE is not None and 'ROLE' not in already_processed:
            already_processed.append('ROLE')
            showIndent(outfile, level)
            outfile.write('ROLE = "%s",\n' % (self.ROLE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.OTHERROLE is not None and 'OTHERROLE' not in already_processed:
            already_processed.append('OTHERROLE')
            showIndent(outfile, level)
            outfile.write('OTHERROLE = "%s",\n' % (self.OTHERROLE,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(note_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = find_attr_value_('OTHERTYPE', node)
        if value is not None and 'OTHERTYPE' not in already_processed:
            already_processed.append('OTHERTYPE')
            self.OTHERTYPE = value
        value = find_attr_value_('ROLE', node)
        if value is not None and 'ROLE' not in already_processed:
            already_processed.append('ROLE')
            self.ROLE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('OTHERROLE', node)
        if value is not None and 'OTHERROLE' not in already_processed:
            already_processed.append('OTHERROLE')
            self.OTHERROLE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'note':
            note_ = child_.text
            note_ = self.gds_validate_string(note_, node, 'note')
            self.note.append(note_)
# end class agentType


class altRecordIDType(GeneratedsSuper):
    """ ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    TYPE (string/O): A description of the identifier type (e.g.,
    OCLC record number, LCCN, etc.). Added valuelist, Karin
    BredenbergRemoved type, Karin Bredenberg type="xsd:string" """
    subclass = None
    superclass = None
    def __init__(self, TYPE=None, ID=None, valueOf_=None):
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if altRecordIDType.subclass:
            return altRecordIDType.subclass(*args_, **kwargs_)
        else:
            return altRecordIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='altRecordIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='altRecordIDType')
        if self.hasContent_():
            outfile.write('>')
            # ESS Fix for unicode string type
            #outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            outfile.write(self.valueOf_.encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='altRecordIDType'):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='altRecordIDType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='altRecordIDType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class altRecordIDType


class metsDocumentIDType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    TYPE (string/O): A description of the identifier type."""
    subclass = None
    superclass = None
    def __init__(self, TYPE=None, ID=None, valueOf_=None):
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if metsDocumentIDType.subclass:
            return metsDocumentIDType.subclass(*args_, **kwargs_)
        else:
            return metsDocumentIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='metsDocumentIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metsDocumentIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='metsDocumentIDType'):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='metsDocumentIDType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metsDocumentIDType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class metsDocumentIDType


class fileSecType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, fileGrp=None):
        self.ID = _cast(None, ID)
        if fileGrp is None:
            self.fileGrp = []
        else:
            self.fileGrp = fileGrp
    def factory(*args_, **kwargs_):
        if fileSecType.subclass:
            return fileSecType.subclass(*args_, **kwargs_)
        else:
            return fileSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileGrp(self): return self.fileGrp
    def set_fileGrp(self, fileGrp): self.fileGrp = fileGrp
    def add_fileGrp(self, value): self.fileGrp.append(value)
    def insert_fileGrp(self, index, value): self.fileGrp[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='fileSecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fileSecType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='fileSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileGrp_ in self.fileGrp:
            fileGrp_.export(outfile, level, namespace_, name_='fileGrp', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.fileGrp
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileSecType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('fileGrp=[\n')
        level += 1
        for fileGrp_ in self.fileGrp:
            showIndent(outfile, level)
            outfile.write('model_.fileGrpType1(\n')
            fileGrp_.exportLiteral(outfile, level, name_='fileGrpType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileGrp':
            obj_ = fileGrpType1.factory()
            obj_.build(child_)
            self.fileGrp.append(obj_)
# end class fileSecType


class fileGrpType1(fileGrpType):
    subclass = None
    superclass = fileGrpType
    def __init__(self, VERSDATE=None, ADMID=None, ID=None, USE=None, fileGrp=None, file=None):
        super(fileGrpType1, self).__init__(VERSDATE, ADMID, ID, USE, fileGrp, file, )
        pass
    def factory(*args_, **kwargs_):
        if fileGrpType1.subclass:
            return fileGrpType1.subclass(*args_, **kwargs_)
        else:
            return fileGrpType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='fileGrpType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileGrpType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fileGrpType1'):
        super(fileGrpType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='fileGrpType1')
    def exportChildren(self, outfile, level, namespace_='', name_='fileGrpType1', fromsubclass_=False, pretty_print=True):
        super(fileGrpType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(fileGrpType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileGrpType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(fileGrpType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileGrpType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(fileGrpType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(fileGrpType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class fileGrpType1


class structLinkType1(structLinkType):
    subclass = None
    superclass = structLinkType
    def __init__(self, ID=None, smLink=None, smLinkGrp=None):
        super(structLinkType1, self).__init__(ID, smLink, smLinkGrp, )
        pass
    def factory(*args_, **kwargs_):
        if structLinkType1.subclass:
            return structLinkType1.subclass(*args_, **kwargs_)
        else:
            return structLinkType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='structLinkType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='structLinkType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='structLinkType1'):
        super(structLinkType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='structLinkType1')
    def exportChildren(self, outfile, level, namespace_='', name_='structLinkType1', fromsubclass_=False, pretty_print=True):
        super(structLinkType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(structLinkType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structLinkType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(structLinkType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(structLinkType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(structLinkType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(structLinkType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class structLinkType1


class mptrType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    CONTENTIDS (URI/O): Content IDs for the content represented by
    the <mptr> (equivalent to DIDL DII or Digital Item Identifier, a
    unique external ID)."""
    subclass = None
    superclass = None
    def __init__(self, arcrole=None, show=None, OTHERLOCTYPE=None, title=None, actuate=None, href=None, role=None, LOCTYPE=None, CONTENTIDS=None, type_=None, ID=None):
        self.arcrole = _cast(None, arcrole)
        self.show = _cast(None, show)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if mptrType.subclass:
            return mptrType.subclass(*args_, **kwargs_)
        else:
            return mptrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_OTHERLOCTYPE(self): return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE): self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_LOCTYPE(self): return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE): self.LOCTYPE = LOCTYPE
    def get_CONTENTIDS(self): return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS): self.CONTENTIDS = CONTENTIDS
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='mptrType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mptrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mptrType'):
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding), input_name='OTHERLOCTYPE'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding), input_name='LOCTYPE'), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (quote_attrib(self.CONTENTIDS), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mptrType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mptrType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n' % (self.OTHERLOCTYPE,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE,))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mptrType


class fptrType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    FILEID (IDREF/O): An optional attribute that provides the XML ID
    identifying the <file> element that links to and/or contains the
    digital content represented by the <fptr>. A <fptr> element
    should only have a FILEID attribute value if it does not have a
    child <area>, <par> or <seq> element. If it has a child element,
    then the responsibility for pointing to the relevant content
    falls to this child element or its descendants. Changed use from
    optional to mandatory, Karin BredenbergCONTENTIDS (URI/O):
    Content IDs for the content represented by the <fptr>
    (equivalent to DIDL DII or Digital Item Identifier, a unique
    external ID)."""
    subclass = None
    superclass = None
    def __init__(self, CONTENTIDS=None, ID=None, FILEID=None, par=None, seq=None, area=None):
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.ID = _cast(None, ID)
        self.FILEID = _cast(None, FILEID)
        self.par = par
        self.seq = seq
        self.area = area
    def factory(*args_, **kwargs_):
        if fptrType.subclass:
            return fptrType.subclass(*args_, **kwargs_)
        else:
            return fptrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_par(self): return self.par
    def set_par(self, par): self.par = par
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_CONTENTIDS(self): return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS): self.CONTENTIDS = CONTENTIDS
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_FILEID(self): return self.FILEID
    def set_FILEID(self, FILEID): self.FILEID = FILEID
    def export(self, outfile, level, namespace_='', name_='fptrType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fptrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fptrType'):
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (quote_attrib(self.CONTENTIDS), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            outfile.write(' FILEID=%s' % (self.gds_format_string(quote_attrib(self.FILEID).encode(ExternalEncoding), input_name='FILEID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='fptrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.par is not None:
            self.par.export(outfile, level, namespace_, name_='par', pretty_print=pretty_print)
        if self.seq is not None:
            self.seq.export(outfile, level, namespace_, name_='seq', pretty_print=pretty_print)
        if self.area is not None:
            self.area.export(outfile, level, namespace_, name_='area', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.par is not None or
            self.seq is not None or
            self.area is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fptrType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            showIndent(outfile, level)
            outfile.write('FILEID = "%s",\n' % (self.FILEID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.par is not None:
            showIndent(outfile, level)
            outfile.write('par=model_.parType(\n')
            self.par.exportLiteral(outfile, level, name_='par')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=model_.seqType(\n')
            self.seq.exportLiteral(outfile, level, name_='seq')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.area is not None:
            showIndent(outfile, level)
            outfile.write('area=model_.areaType(\n')
            self.area.exportLiteral(outfile, level, name_='area')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('FILEID', node)
        if value is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            self.FILEID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'par':
            obj_ = parType.factory()
            obj_.build(child_)
            self.set_par(obj_)
        elif nodeName_ == 'seq':
            obj_ = seqType.factory()
            obj_.build(child_)
            self.set_seq(obj_)
        elif nodeName_ == 'area':
            obj_ = areaType.factory()
            obj_.build(child_)
            self.set_area(obj_)
# end class fptrType


class smLinkType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    xlink:arcrole - the role of the link, as per the xlink
    specification. See http://www.w3.org/TR/xlink/ xlink:title - a
    title for the link (if needed), as per the xlink specification.
    See http://www.w3.org/TR/xlink/ xlink:show - see the xlink
    specification at http://www.w3.org/TR/xlink/ xlink:actuate - see
    the xlink specification at http://www.w3.org/TR/xlink/ xlink:to
    - the value of the label for the element in the structMap you
    are linking to. xlink:from - the value of the label for the
    element in the structMap you are linking from."""
    subclass = None
    superclass = None
    def __init__(self, fromxx=None, show=None, title=None, actuate=None, to=None, arcrole=None, ID=None):
        self.fromxx = _cast(None, fromxx)
        self.show = _cast(None, show)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.to = _cast(None, to)
        self.arcrole = _cast(None, arcrole)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if smLinkType.subclass:
            return smLinkType.subclass(*args_, **kwargs_)
        else:
            return smLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_from(self): return self.fromxx
    def set_from(self, fromxx): self.fromxx = fromxx
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='smLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='smLinkType'):
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='smLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smLinkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smLinkType


class smLinkGrpType(GeneratedsSuper):
    """ARCLINKORDER (enumerated string/O): ARCLINKORDER is used to indicate
    whether the order of the smArcLink elements aggregated by the
    smLinkGrp element is significant. If the order is significant,
    then a value of "ordered" should be supplied. Value defaults to
    "unordered" Note that the ARLINKORDER attribute has no xlink
    specified meaning."""
    subclass = None
    superclass = None
    def __init__(self, role=None, title=None, ARCLINKORDER='unordered', ID=None, type_=None, smLocatorLink=None, smArcLink=None):
        self.role = _cast(None, role)
        self.title = _cast(None, title)
        self.ARCLINKORDER = _cast(None, ARCLINKORDER)
        self.ID = _cast(None, ID)
        self.type_ = _cast(None, type_)
        if smLocatorLink is None:
            self.smLocatorLink = []
        else:
            self.smLocatorLink = smLocatorLink
        if smArcLink is None:
            self.smArcLink = []
        else:
            self.smArcLink = smArcLink
    def factory(*args_, **kwargs_):
        if smLinkGrpType.subclass:
            return smLinkGrpType.subclass(*args_, **kwargs_)
        else:
            return smLinkGrpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_smLocatorLink(self): return self.smLocatorLink
    def set_smLocatorLink(self, smLocatorLink): self.smLocatorLink = smLocatorLink
    def add_smLocatorLink(self, value): self.smLocatorLink.append(value)
    def insert_smLocatorLink(self, index, value): self.smLocatorLink[index] = value
    def get_smArcLink(self): return self.smArcLink
    def set_smArcLink(self, smArcLink): self.smArcLink = smArcLink
    def add_smArcLink(self, value): self.smArcLink.append(value)
    def insert_smArcLink(self, index, value): self.smArcLink[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_ARCLINKORDER(self): return self.ARCLINKORDER
    def set_ARCLINKORDER(self, ARCLINKORDER): self.ARCLINKORDER = ARCLINKORDER
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='smLinkGrpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smLinkGrpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='smLinkGrpType'):
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.ARCLINKORDER is not None and 'ARCLINKORDER' not in already_processed:
            already_processed.append('ARCLINKORDER')
            outfile.write(' ARCLINKORDER=%s' % (self.gds_format_string(quote_attrib(self.ARCLINKORDER).encode(ExternalEncoding), input_name='ARCLINKORDER'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='smLinkGrpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for smLocatorLink_ in self.smLocatorLink:
            smLocatorLink_.export(outfile, level, namespace_, name_='smLocatorLink', pretty_print=pretty_print)
        for smArcLink_ in self.smArcLink:
            smArcLink_.export(outfile, level, namespace_, name_='smArcLink', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.smLocatorLink or
            self.smArcLink
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smLinkGrpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.ARCLINKORDER is not None and 'ARCLINKORDER' not in already_processed:
            already_processed.append('ARCLINKORDER')
            showIndent(outfile, level)
            outfile.write('ARCLINKORDER = "%s",\n' % (self.ARCLINKORDER,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('smLocatorLink=[\n')
        level += 1
        for smLocatorLink_ in self.smLocatorLink:
            showIndent(outfile, level)
            outfile.write('model_.smLocatorLinkType(\n')
            smLocatorLink_.exportLiteral(outfile, level, name_='smLocatorLinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smArcLink=[\n')
        level += 1
        for smArcLink_ in self.smArcLink:
            showIndent(outfile, level)
            outfile.write('model_.smArcLinkType(\n')
            smArcLink_.exportLiteral(outfile, level, name_='smArcLinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('ARCLINKORDER', node)
        if value is not None and 'ARCLINKORDER' not in already_processed:
            already_processed.append('ARCLINKORDER')
            self.ARCLINKORDER = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'smLocatorLink':
            obj_ = smLocatorLinkType.factory()
            obj_.build(child_)
            self.smLocatorLink.append(obj_)
        elif nodeName_ == 'smArcLink':
            obj_ = smArcLinkType.factory()
            obj_.build(child_)
            self.smArcLink.append(obj_)
# end class smLinkGrpType


class smLocatorLinkType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, title=None, label=None, href=None, role=None, type_=None, ID=None):
        self.title = _cast(None, title)
        self.label = _cast(None, label)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if smLocatorLinkType.subclass:
            return smLocatorLinkType.subclass(*args_, **kwargs_)
        else:
            return smLocatorLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='smLocatorLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smLocatorLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='smLocatorLinkType'):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='smLocatorLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smLocatorLinkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smLocatorLinkType


class smArcLinkType(GeneratedsSuper):
    """The structMap arc link element <smArcLink> is of xlink:type "arc" It
    can be used to establish a traversal link between two <div>
    elements as identified by <smLocatorLink> elements within the
    same smLinkGrp element. The associated xlink:from and xlink:to
    attributes identify the from and to sides of the arc link by
    referencing the xlink:label attribute values on the
    participating smLocatorLink elements. ID (ID/O): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external
    linking see Chapter 4 of the METS Primer.ARCTYPE (string/O):The
    ARCTYPE attribute provides a means of specifying the
    relationship between the <div> elements participating in the arc
    link, and hence the purpose or role of the link. While it can be
    considered analogous to the xlink:arcrole attribute, its type is
    a simple string, rather than anyURI. ARCTYPE has no xlink
    specified meaning, and the xlink:arcrole attribute should be
    used instead of or in addition to the ARCTYPE attribute when
    full xlink compliance is desired with respect to specifying the
    role or purpose of the arc link. ADMID (IDREFS/O): Contains the
    ID attribute values identifying the <sourceMD>, <techMD>,
    <digiprovMD> and/or <rightsMD> elements within the <amdSec> of
    the METS document that contain or link to administrative
    metadata pertaining to <smArcLink>. Typically the <smArcLink>
    ADMID attribute would be used to identify one or more <sourceMD>
    and/or <techMD> elements that refine or clarify the relationship
    between the xlink:from and xlink:to sides of the arc. For more
    information on using METS IDREFS and IDREF type attributes for
    internal linking, see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ADMID=None, fromxx=None, title=None, show=None, actuate=None, ARCTYPE=None, to=None, arcrole=None, type_=None, ID=None):
        self.ADMID = _cast(None, ADMID)
        self.fromxx = _cast(None, fromxx)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.ARCTYPE = _cast(None, ARCTYPE)
        self.to = _cast(None, to)
        self.arcrole = _cast(None, arcrole)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if smArcLinkType.subclass:
            return smArcLinkType.subclass(*args_, **kwargs_)
        else:
            return smArcLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_from(self): return self.fromxx
    def set_from(self, fromxx): self.fromxx = fromxx
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_ARCTYPE(self): return self.ARCTYPE
    def set_ARCTYPE(self, ARCTYPE): self.ARCTYPE = ARCTYPE
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='smArcLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smArcLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='smArcLinkType'):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.ARCTYPE is not None and 'ARCTYPE' not in already_processed:
            already_processed.append('ARCTYPE')
            outfile.write(' ARCTYPE=%s' % (self.gds_format_string(quote_attrib(self.ARCTYPE).encode(ExternalEncoding), input_name='ARCTYPE'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='smArcLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smArcLinkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.ARCTYPE is not None and 'ARCTYPE' not in already_processed:
            already_processed.append('ARCTYPE')
            showIndent(outfile, level)
            outfile.write('ARCTYPE = "%s",\n' % (self.ARCTYPE,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('ARCTYPE', node)
        if value is not None and 'ARCTYPE' not in already_processed:
            already_processed.append('ARCTYPE')
            self.ARCTYPE = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smArcLinkType


class mdRefType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    LABEL (string/O): Provides a label to display to the viewer of
    the METS document that identifies the associated metadata. XPTR
    (string/O): Locates the point within a file to which the <mdRef>
    element refers, if applicable."""
    subclass = None
    superclass = None
    def __init__(self, MIMETYPE=None, arcrole=None, XPTR=None, CHECKSUMTYPE=None, show=None, OTHERLOCTYPE=None, CHECKSUM=None, OTHERMDTYPE=None, title=None, actuate=None, MDTYPE=None, LABEL=None, href=None, role=None, LOCTYPE=None, MDTYPEVERSION=None, CREATED=None, type_=None, ID=None, SIZE=None):
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.arcrole = _cast(None, arcrole)
        self.XPTR = _cast(None, XPTR)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.show = _cast(None, show)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.OTHERMDTYPE = _cast(None, OTHERMDTYPE)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.MDTYPE = _cast(None, MDTYPE)
        self.LABEL = _cast(None, LABEL)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.MDTYPEVERSION = _cast(None, MDTYPEVERSION)
        self.CREATED = _cast(None, CREATED)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.SIZE = _cast(int, SIZE)
        pass
    def factory(*args_, **kwargs_):
        if mdRefType.subclass:
            return mdRefType.subclass(*args_, **kwargs_)
        else:
            return mdRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MIMETYPE(self): return self.MIMETYPE
    def set_MIMETYPE(self, MIMETYPE): self.MIMETYPE = MIMETYPE
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_XPTR(self): return self.XPTR
    def set_XPTR(self, XPTR): self.XPTR = XPTR
    def get_CHECKSUMTYPE(self): return self.CHECKSUMTYPE
    def set_CHECKSUMTYPE(self, CHECKSUMTYPE): self.CHECKSUMTYPE = CHECKSUMTYPE
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_OTHERLOCTYPE(self): return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE): self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_CHECKSUM(self): return self.CHECKSUM
    def set_CHECKSUM(self, CHECKSUM): self.CHECKSUM = CHECKSUM
    def get_OTHERMDTYPE(self): return self.OTHERMDTYPE
    def set_OTHERMDTYPE(self, OTHERMDTYPE): self.OTHERMDTYPE = OTHERMDTYPE
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_MDTYPE(self): return self.MDTYPE
    def set_MDTYPE(self, MDTYPE): self.MDTYPE = MDTYPE
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_LOCTYPE(self): return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE): self.LOCTYPE = LOCTYPE
    def get_MDTYPEVERSION(self): return self.MDTYPEVERSION
    def set_MDTYPEVERSION(self, MDTYPEVERSION): self.MDTYPEVERSION = MDTYPEVERSION
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def export(self, outfile, level, namespace_='', name_='mdRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mdRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mdRefType'):
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            outfile.write(' MIMETYPE=%s' % (self.gds_format_string(quote_attrib(self.MIMETYPE).encode(ExternalEncoding), input_name='MIMETYPE'), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.XPTR is not None and 'XPTR' not in already_processed:
            already_processed.append('XPTR')
            outfile.write(' XPTR=%s' % (self.gds_format_string(quote_attrib(self.XPTR).encode(ExternalEncoding), input_name='XPTR'), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s' % (self.gds_format_string(quote_attrib(self.CHECKSUMTYPE).encode(ExternalEncoding), input_name='CHECKSUMTYPE'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding), input_name='OTHERLOCTYPE'), ))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            outfile.write(' CHECKSUM=%s' % (self.gds_format_string(quote_attrib(self.CHECKSUM).encode(ExternalEncoding), input_name='CHECKSUM'), ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            outfile.write(' OTHERMDTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERMDTYPE).encode(ExternalEncoding), input_name='OTHERMDTYPE'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.MDTYPE is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            outfile.write(' MDTYPE=%s' % (self.gds_format_string(quote_attrib(self.MDTYPE).encode(ExternalEncoding), input_name='MDTYPE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' xlink:href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding), input_name='LOCTYPE'), ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.append('MDTYPEVERSION')
            outfile.write(' MDTYPEVERSION=%s' % (self.gds_format_string(quote_attrib(self.MDTYPEVERSION).encode(ExternalEncoding), input_name='MDTYPEVERSION'), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s' % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding), input_name='CREATED'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' xlink:type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
    def exportChildren(self, outfile, level, namespace_='', name_='mdRefType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mdRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            showIndent(outfile, level)
            outfile.write('MIMETYPE = "%s",\n' % (self.MIMETYPE,))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.XPTR is not None and 'XPTR' not in already_processed:
            already_processed.append('XPTR')
            showIndent(outfile, level)
            outfile.write('XPTR = "%s",\n' % (self.XPTR,))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            showIndent(outfile, level)
            outfile.write('CHECKSUMTYPE = "%s",\n' % (self.CHECKSUMTYPE,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n' % (self.OTHERLOCTYPE,))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            showIndent(outfile, level)
            outfile.write('CHECKSUM = "%s",\n' % (self.CHECKSUM,))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERMDTYPE = "%s",\n' % (self.OTHERMDTYPE,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.MDTYPE is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            showIndent(outfile, level)
            outfile.write('MDTYPE = "%s",\n' % (self.MDTYPE,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE,))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.append('MDTYPEVERSION')
            showIndent(outfile, level)
            outfile.write('MDTYPEVERSION = "%s",\n' % (self.MDTYPEVERSION,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE = %d,\n' % (self.SIZE,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MIMETYPE', node)
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            self.MIMETYPE = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('XPTR', node)
        if value is not None and 'XPTR' not in already_processed:
            already_processed.append('XPTR')
            self.XPTR = value
        value = find_attr_value_('CHECKSUMTYPE', node)
        if value is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('CHECKSUM', node)
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            self.CHECKSUM = value
        value = find_attr_value_('OTHERMDTYPE', node)
        if value is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            self.OTHERMDTYPE = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('MDTYPE', node)
        if value is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            self.MDTYPE = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('MDTYPEVERSION', node)
        if value is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.append('MDTYPEVERSION')
            self.MDTYPEVERSION = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mdRefType


class mdWrapType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    Changed reference so it can be different demands on mdRef and
    mdWrap. Karin BredenbergLABEL: an optional string attribute
    providing a label to display to the viewer of the METS document
    identifying the metadata."""
    subclass = None
    superclass = None
    def __init__(self, MIMETYPE=None, CHECKSUMTYPE=None, CREATED=None, CHECKSUM=None, OTHERMDTYPE=None, MDTYPE=None, LABEL=None, MDTYPEVERSION=None, ID=None, SIZE=None, binData=None, xmlData=None):
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.CREATED = _cast(None, CREATED)
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.OTHERMDTYPE = _cast(None, OTHERMDTYPE)
        self.MDTYPE = _cast(None, MDTYPE)
        self.LABEL = _cast(None, LABEL)
        self.MDTYPEVERSION = _cast(None, MDTYPEVERSION)
        self.ID = _cast(None, ID)
        self.SIZE = _cast(int, SIZE)
        self.binData = binData
        self.xmlData = xmlData
    def factory(*args_, **kwargs_):
        if mdWrapType.subclass:
            return mdWrapType.subclass(*args_, **kwargs_)
        else:
            return mdWrapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_binData(self): return self.binData
    def set_binData(self, binData): self.binData = binData
    def get_xmlData(self): return self.xmlData
    def set_xmlData(self, xmlData): self.xmlData = xmlData
    def get_MIMETYPE(self): return self.MIMETYPE
    def set_MIMETYPE(self, MIMETYPE): self.MIMETYPE = MIMETYPE
    def get_CHECKSUMTYPE(self): return self.CHECKSUMTYPE
    def set_CHECKSUMTYPE(self, CHECKSUMTYPE): self.CHECKSUMTYPE = CHECKSUMTYPE
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def get_CHECKSUM(self): return self.CHECKSUM
    def set_CHECKSUM(self, CHECKSUM): self.CHECKSUM = CHECKSUM
    def get_OTHERMDTYPE(self): return self.OTHERMDTYPE
    def set_OTHERMDTYPE(self, OTHERMDTYPE): self.OTHERMDTYPE = OTHERMDTYPE
    def get_MDTYPE(self): return self.MDTYPE
    def set_MDTYPE(self, MDTYPE): self.MDTYPE = MDTYPE
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_MDTYPEVERSION(self): return self.MDTYPEVERSION
    def set_MDTYPEVERSION(self, MDTYPEVERSION): self.MDTYPEVERSION = MDTYPEVERSION
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def export(self, outfile, level, namespace_='', name_='mdWrapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mdWrapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mdWrapType'):
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            outfile.write(' MIMETYPE=%s' % (self.gds_format_string(quote_attrib(self.MIMETYPE).encode(ExternalEncoding), input_name='MIMETYPE'), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s' % (self.gds_format_string(quote_attrib(self.CHECKSUMTYPE).encode(ExternalEncoding), input_name='CHECKSUMTYPE'), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s' % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding), input_name='CREATED'), ))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            outfile.write(' CHECKSUM=%s' % (self.gds_format_string(quote_attrib(self.CHECKSUM).encode(ExternalEncoding), input_name='CHECKSUM'), ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            outfile.write(' OTHERMDTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERMDTYPE).encode(ExternalEncoding), input_name='OTHERMDTYPE'), ))
        if self.MDTYPE is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            outfile.write(' MDTYPE=%s' % (self.gds_format_string(quote_attrib(self.MDTYPE).encode(ExternalEncoding), input_name='MDTYPE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.append('MDTYPEVERSION')
            outfile.write(' MDTYPEVERSION=%s' % (self.gds_format_string(quote_attrib(self.MDTYPEVERSION).encode(ExternalEncoding), input_name='MDTYPEVERSION'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
    def exportChildren(self, outfile, level, namespace_='', name_='mdWrapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.binData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbinData>%s</%sbinData>%s' % (namespace_, self.gds_format_string(quote_xml(self.binData).encode(ExternalEncoding), input_name='binData'), namespace_, eol_))
        if self.xmlData is not None:
            self.xmlData.export(outfile, level, namespace_, name_='xmlData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.binData is not None or
            self.xmlData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mdWrapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            showIndent(outfile, level)
            outfile.write('MIMETYPE = "%s",\n' % (self.MIMETYPE,))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            showIndent(outfile, level)
            outfile.write('CHECKSUMTYPE = "%s",\n' % (self.CHECKSUMTYPE,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED,))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            showIndent(outfile, level)
            outfile.write('CHECKSUM = "%s",\n' % (self.CHECKSUM,))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERMDTYPE = "%s",\n' % (self.OTHERMDTYPE,))
        if self.MDTYPE is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            showIndent(outfile, level)
            outfile.write('MDTYPE = "%s",\n' % (self.MDTYPE,))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL,))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.append('MDTYPEVERSION')
            showIndent(outfile, level)
            outfile.write('MDTYPEVERSION = "%s",\n' % (self.MDTYPEVERSION,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE = %d,\n' % (self.SIZE,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.binData is not None:
            showIndent(outfile, level)
            outfile.write('binData=%s,\n' % quote_python(self.binData).encode(ExternalEncoding))
        if self.xmlData is not None:
            showIndent(outfile, level)
            outfile.write('xmlData=model_.xmlDataType(\n')
            self.xmlData.exportLiteral(outfile, level, name_='xmlData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MIMETYPE', node)
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            self.MIMETYPE = value
        value = find_attr_value_('CHECKSUMTYPE', node)
        if value is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = find_attr_value_('CHECKSUM', node)
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            self.CHECKSUM = value
        value = find_attr_value_('OTHERMDTYPE', node)
        if value is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            self.OTHERMDTYPE = value
        value = find_attr_value_('MDTYPE', node)
        if value is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            self.MDTYPE = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = find_attr_value_('MDTYPEVERSION', node)
        if value is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.append('MDTYPEVERSION')
            self.MDTYPEVERSION = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'binData':
            binData_ = child_.text
            binData_ = self.gds_validate_string(binData_, node, 'binData')
            self.binData = binData_
        elif nodeName_ == 'xmlData':
            obj_ = xmlDataType.factory()
            obj_.build(child_)
            self.set_xmlData(obj_)
# end class mdWrapType


class xmlDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if xmlDataType.subclass:
            return xmlDataType.subclass(*args_, **kwargs_)
        else:
            return xmlDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='xmlDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xmlDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xmlDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xmlDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='xmlDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'xmlDataType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class xmlDataType


class FLocatType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    USE (string/O): A tagging attribute to indicate the intended use
    of the specific copy of the file represented by the <FLocat>
    element (e.g., service master, archive master). A USE attribute
    can be expressed at the<fileGrp> level, the <file> level, the
    <FLocat> level and/or the <FContent> level. A USE attribute
    value at the <fileGrp> level should pertain to all of the files
    in the <fileGrp>. A USE attribute at the <file> level should
    pertain to all copies of the file as represented by subsidiary
    <FLocat> and/or <FContent> elements. A USE attribute at the
    <FLocat> or <FContent> level pertains to the particular copy of
    the file that is either referenced (<FLocat>) or wrapped
    (<FContent>)."""
    subclass = None
    superclass = None
    def __init__(self, arcrole=None, USE=None, title=None, OTHERLOCTYPE=None, show=None, actuate=None, href=None, role=None, LOCTYPE=None, type_=None, ID=None):
        self.arcrole = _cast(None, arcrole)
        self.USE = _cast(None, USE)
        self.title = _cast(None, title)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if FLocatType.subclass:
            return FLocatType.subclass(*args_, **kwargs_)
        else:
            return FLocatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arcrole(self): return self.arcrole
    def set_arcrole(self, arcrole): self.arcrole = arcrole
    def get_USE(self): return self.USE
    def set_USE(self, USE): self.USE = USE
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_OTHERLOCTYPE(self): return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE): self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_show(self): return self.show
    def set_show(self, show): self.show = show
    def get_actuate(self): return self.actuate
    def set_actuate(self, actuate): self.actuate = actuate
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_LOCTYPE(self): return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE): self.LOCTYPE = LOCTYPE
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='FLocatType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FLocatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FLocatType'):
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s' % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding), input_name='arcrole'), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s' % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding), input_name='USE'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding), input_name='OTHERLOCTYPE'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s' % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding), input_name='show'), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s' % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding), input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' xlink:href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding), input_name='LOCTYPE'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' xlink:type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FLocatType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FLocatType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole,))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n' % (self.OTHERLOCTYPE,))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show,))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.LOCTYPE is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FLocatType


class FContentType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    USE (string/O): A tagging attribute to indicate the intended use
    of the specific copy of the file represented by the <FContent>
    element (e.g., service master, archive master). A USE attribute
    can be expressed at the<fileGrp> level, the <file> level, the
    <FLocat> level and/or the <FContent> level. A USE attribute
    value at the <fileGrp> level should pertain to all of the files
    in the <fileGrp>. A USE attribute at the <file> level should
    pertain to all copies of the file as represented by subsidiary
    <FLocat> and/or <FContent> elements. A USE attribute at the
    <FLocat> or <FContent> level pertains to the particular copy of
    the file that is either referenced (<FLocat>) or wrapped
    (<FContent>)."""
    subclass = None
    superclass = None
    def __init__(self, USE=None, ID=None, binData=None, xmlData=None):
        self.USE = _cast(None, USE)
        self.ID = _cast(None, ID)
        self.binData = binData
        self.xmlData = xmlData
    def factory(*args_, **kwargs_):
        if FContentType.subclass:
            return FContentType.subclass(*args_, **kwargs_)
        else:
            return FContentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_binData(self): return self.binData
    def set_binData(self, binData): self.binData = binData
    def get_xmlData(self): return self.xmlData
    def set_xmlData(self, xmlData): self.xmlData = xmlData
    def get_USE(self): return self.USE
    def set_USE(self, USE): self.USE = USE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='FContentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FContentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FContentType'):
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s' % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding), input_name='USE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FContentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.binData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbinData>%s</%sbinData>%s' % (namespace_, self.gds_format_string(quote_xml(self.binData).encode(ExternalEncoding), input_name='binData'), namespace_, eol_))
        if self.xmlData is not None:
            self.xmlData.export(outfile, level, namespace_, name_='xmlData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.binData is not None or
            self.xmlData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FContentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.binData is not None:
            showIndent(outfile, level)
            outfile.write('binData=%s,\n' % quote_python(self.binData).encode(ExternalEncoding))
        if self.xmlData is not None:
            showIndent(outfile, level)
            outfile.write('xmlData=model_.xmlDataType1(\n')
            self.xmlData.exportLiteral(outfile, level, name_='xmlData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'binData':
            binData_ = child_.text
            binData_ = self.gds_validate_string(binData_, node, 'binData')
            self.binData = binData_
        elif nodeName_ == 'xmlData':
            obj_ = xmlDataType1.factory()
            obj_.build(child_)
            self.set_xmlData(obj_)
# end class FContentType


class xmlDataType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if xmlDataType1.subclass:
            return xmlDataType1.subclass(*args_, **kwargs_)
        else:
            return xmlDataType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='xmlDataType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xmlDataType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xmlDataType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xmlDataType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='xmlDataType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'xmlDataType1')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class xmlDataType1


class streamType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    streamType (string/O): The IANA MIME media type for the
    bytestream.OWNERID (string/O): Used to provide a unique
    identifier (which could include a URI) assigned to the file.
    This identifier may differ from the URI used to retrieve the
    file. ADMID (IDREFS/O): Contains the ID attribute values of the
    <techMD>, <sourceMD>, <rightsMD> and/or <digiprovMD> elements
    within the <amdSec> of the METS document that contain
    administrative metadata pertaining to the bytestream. For more
    information on using METS IDREFS and IDREF type attributes for
    internal linking, see Chapter 4 of the METS Primer. DMDID
    (IDREFS/O): Contains the ID attribute values identifying the
    <dmdSec>, elements in the METS document that contain or link to
    descriptive metadata pertaining to the content file stream
    represented by the current <stream> element. For more
    information on using METS IDREFS and IDREF type attributes for
    internal linking, see Chapter 4 of the METS Primer. BEGIN
    (string/O): An attribute that specifies the point in the parent
    <file> where the current <stream> begins. It can be used in
    conjunction with the END attribute as a means of defining the
    location of the stream within its parent file. However, the
    BEGIN attribute can be used with or without a companion END
    attribute. When no END attribute is specified, the end of the
    parent file is assumed also to be the end point of the stream.
    The BEGIN and END attributes can only be interpreted
    meaningfully in conjunction with a BETYPE attribute, which
    specifies the kind of beginning/ending point values that are
    being used. END (string/O): An attribute that specifies the
    point in the parent <file> where the <stream> ends. It can only
    be interpreted meaningfully in conjunction with the BETYPE,
    which specifies the kind of ending point values being used.
    Typically the END attribute would only appear in conjunction
    with a BEGIN attribute. BETYPE: Begin/End Type. BETYPE
    (string/O): An attribute that specifies the kind of BEGIN and/or
    END values that are being used. Currently BYTE is the only valid
    value that can be used in conjunction with nested <file> or
    <stream> elements."""
    subclass = None
    superclass = None
    def __init__(self, BEGIN=None, END=None, ADMID=None, BETYPE=None, streamType=None, DMDID=None, OWNERID=None, ID=None):
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.ADMID = _cast(None, ADMID)
        self.BETYPE = _cast(None, BETYPE)
        self.streamType = _cast(None, streamType)
        self.DMDID = _cast(None, DMDID)
        self.OWNERID = _cast(None, OWNERID)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if streamType.subclass:
            return streamType.subclass(*args_, **kwargs_)
        else:
            return streamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BEGIN(self): return self.BEGIN
    def set_BEGIN(self, BEGIN): self.BEGIN = BEGIN
    def get_END(self): return self.END
    def set_END(self, END): self.END = END
    def get_ADMID(self): return self.ADMID
    def set_ADMID(self, ADMID): self.ADMID = ADMID
    def get_BETYPE(self): return self.BETYPE
    def set_BETYPE(self, BETYPE): self.BETYPE = BETYPE
    def get_streamType(self): return self.streamType
    def set_streamType(self, streamType): self.streamType = streamType
    def get_DMDID(self): return self.DMDID
    def set_DMDID(self, DMDID): self.DMDID = DMDID
    def get_OWNERID(self): return self.OWNERID
    def set_OWNERID(self, OWNERID): self.OWNERID = OWNERID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='streamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streamType'):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            outfile.write(' BEGIN=%s' % (self.gds_format_string(quote_attrib(self.BEGIN).encode(ExternalEncoding), input_name='BEGIN'), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            outfile.write(' END=%s' % (self.gds_format_string(quote_attrib(self.END).encode(ExternalEncoding), input_name='END'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding), input_name='ADMID'), ))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            outfile.write(' BETYPE=%s' % (self.gds_format_string(quote_attrib(self.BETYPE).encode(ExternalEncoding), input_name='BETYPE'), ))
        if self.streamType is not None and 'streamType' not in already_processed:
            already_processed.append('streamType')
            outfile.write(' streamType=%s' % (self.gds_format_string(quote_attrib(self.streamType).encode(ExternalEncoding), input_name='streamType'), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            outfile.write(' DMDID=%s' % (self.gds_format_string(quote_attrib(self.DMDID).encode(ExternalEncoding), input_name='DMDID'), ))
        if self.OWNERID is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            outfile.write(' OWNERID=%s' % (self.gds_format_string(quote_attrib(self.OWNERID).encode(ExternalEncoding), input_name='OWNERID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streamType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='streamType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            showIndent(outfile, level)
            outfile.write('BEGIN = "%s",\n' % (self.BEGIN,))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            showIndent(outfile, level)
            outfile.write('END = "%s",\n' % (self.END,))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID,))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            showIndent(outfile, level)
            outfile.write('BETYPE = "%s",\n' % (self.BETYPE,))
        if self.streamType is not None and 'streamType' not in already_processed:
            already_processed.append('streamType')
            showIndent(outfile, level)
            outfile.write('streamType = "%s",\n' % (self.streamType,))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            showIndent(outfile, level)
            outfile.write('DMDID = "%s",\n' % (self.DMDID,))
        if self.OWNERID is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            showIndent(outfile, level)
            outfile.write('OWNERID = "%s",\n' % (self.OWNERID,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BEGIN', node)
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            self.BEGIN = value
        value = find_attr_value_('END', node)
        if value is not None and 'END' not in already_processed:
            already_processed.append('END')
            self.END = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = find_attr_value_('BETYPE', node)
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            self.BETYPE = value
        value = find_attr_value_('streamType', node)
        if value is not None and 'streamType' not in already_processed:
            already_processed.append('streamType')
            self.streamType = value
        value = find_attr_value_('DMDID', node)
        if value is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            self.DMDID = value
        value = find_attr_value_('OWNERID', node)
        if value is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            self.OWNERID = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class streamType


class transformFileType(GeneratedsSuper):
    """ID (ID/O): This attribute uniquely identifies the element within the
    METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    TRANSFORMTYPE (string/R): Is used to indicate the type of
    transformation needed to render content of a file accessible.
    This may include unpacking a file into subsidiary files/streams.
    The controlled value constraints for this XML string include
    “decompression” and “decryption”. Decompression is
    defined as the action of reversing data compression, i.e., the
    process of encoding information using fewer bits than an
    unencoded representation would use by means of specific encoding
    schemas. Decryption is defined as the process of restoring data
    that has been obscured to make it unreadable without special
    knowledge (encrypted data) to its original form. TRANSFORM-
    ALGORITHM (string/R): Specifies the decompression or decryption
    routine used to access the contents of the file. Algorithms for
    compression can be either loss-less or lossy.TRANSFORMKEY
    (string/O): A key to be used with the transform algorithm for
    accessing the file’s contents.TRANSFORMBEHAVIOR (string/O): An
    IDREF to a behavior element for this
    transformation.TRANSFORMORDER (postive-integer/R): The order in
    which the instructions must be followed in order to unpack or
    transform the container file."""
    subclass = None
    superclass = None
    def __init__(self, TRANSFORMTYPE=None, TRANSFORMKEY=None, TRANSFORMBEHAVIOR=None, TRANSFORMALGORITHM=None, TRANSFORMORDER=None, ID=None):
        self.TRANSFORMTYPE = _cast(None, TRANSFORMTYPE)
        self.TRANSFORMKEY = _cast(None, TRANSFORMKEY)
        self.TRANSFORMBEHAVIOR = _cast(None, TRANSFORMBEHAVIOR)
        self.TRANSFORMALGORITHM = _cast(None, TRANSFORMALGORITHM)
        self.TRANSFORMORDER = _cast(int, TRANSFORMORDER)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if transformFileType.subclass:
            return transformFileType.subclass(*args_, **kwargs_)
        else:
            return transformFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TRANSFORMTYPE(self): return self.TRANSFORMTYPE
    def set_TRANSFORMTYPE(self, TRANSFORMTYPE): self.TRANSFORMTYPE = TRANSFORMTYPE
    def get_TRANSFORMKEY(self): return self.TRANSFORMKEY
    def set_TRANSFORMKEY(self, TRANSFORMKEY): self.TRANSFORMKEY = TRANSFORMKEY
    def get_TRANSFORMBEHAVIOR(self): return self.TRANSFORMBEHAVIOR
    def set_TRANSFORMBEHAVIOR(self, TRANSFORMBEHAVIOR): self.TRANSFORMBEHAVIOR = TRANSFORMBEHAVIOR
    def get_TRANSFORMALGORITHM(self): return self.TRANSFORMALGORITHM
    def set_TRANSFORMALGORITHM(self, TRANSFORMALGORITHM): self.TRANSFORMALGORITHM = TRANSFORMALGORITHM
    def get_TRANSFORMORDER(self): return self.TRANSFORMORDER
    def set_TRANSFORMORDER(self, TRANSFORMORDER): self.TRANSFORMORDER = TRANSFORMORDER
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='', name_='transformFileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transformFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transformFileType'):
        if self.TRANSFORMTYPE is not None and 'TRANSFORMTYPE' not in already_processed:
            already_processed.append('TRANSFORMTYPE')
            outfile.write(' TRANSFORMTYPE=%s' % (self.gds_format_string(quote_attrib(self.TRANSFORMTYPE).encode(ExternalEncoding), input_name='TRANSFORMTYPE'), ))
        if self.TRANSFORMKEY is not None and 'TRANSFORMKEY' not in already_processed:
            already_processed.append('TRANSFORMKEY')
            outfile.write(' TRANSFORMKEY=%s' % (self.gds_format_string(quote_attrib(self.TRANSFORMKEY).encode(ExternalEncoding), input_name='TRANSFORMKEY'), ))
        if self.TRANSFORMBEHAVIOR is not None and 'TRANSFORMBEHAVIOR' not in already_processed:
            already_processed.append('TRANSFORMBEHAVIOR')
            outfile.write(' TRANSFORMBEHAVIOR=%s' % (self.gds_format_string(quote_attrib(self.TRANSFORMBEHAVIOR).encode(ExternalEncoding), input_name='TRANSFORMBEHAVIOR'), ))
        if self.TRANSFORMALGORITHM is not None and 'TRANSFORMALGORITHM' not in already_processed:
            already_processed.append('TRANSFORMALGORITHM')
            outfile.write(' TRANSFORMALGORITHM=%s' % (self.gds_format_string(quote_attrib(self.TRANSFORMALGORITHM).encode(ExternalEncoding), input_name='TRANSFORMALGORITHM'), ))
        if self.TRANSFORMORDER is not None and 'TRANSFORMORDER' not in already_processed:
            already_processed.append('TRANSFORMORDER')
            outfile.write(' TRANSFORMORDER="%s"' % self.gds_format_integer(self.TRANSFORMORDER, input_name='TRANSFORMORDER'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transformFileType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='transformFileType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TRANSFORMTYPE is not None and 'TRANSFORMTYPE' not in already_processed:
            already_processed.append('TRANSFORMTYPE')
            showIndent(outfile, level)
            outfile.write('TRANSFORMTYPE = "%s",\n' % (self.TRANSFORMTYPE,))
        if self.TRANSFORMKEY is not None and 'TRANSFORMKEY' not in already_processed:
            already_processed.append('TRANSFORMKEY')
            showIndent(outfile, level)
            outfile.write('TRANSFORMKEY = "%s",\n' % (self.TRANSFORMKEY,))
        if self.TRANSFORMBEHAVIOR is not None and 'TRANSFORMBEHAVIOR' not in already_processed:
            already_processed.append('TRANSFORMBEHAVIOR')
            showIndent(outfile, level)
            outfile.write('TRANSFORMBEHAVIOR = "%s",\n' % (self.TRANSFORMBEHAVIOR,))
        if self.TRANSFORMALGORITHM is not None and 'TRANSFORMALGORITHM' not in already_processed:
            already_processed.append('TRANSFORMALGORITHM')
            showIndent(outfile, level)
            outfile.write('TRANSFORMALGORITHM = "%s",\n' % (self.TRANSFORMALGORITHM,))
        if self.TRANSFORMORDER is not None and 'TRANSFORMORDER' not in already_processed:
            already_processed.append('TRANSFORMORDER')
            showIndent(outfile, level)
            outfile.write('TRANSFORMORDER = %d,\n' % (self.TRANSFORMORDER,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TRANSFORMTYPE', node)
        if value is not None and 'TRANSFORMTYPE' not in already_processed:
            already_processed.append('TRANSFORMTYPE')
            self.TRANSFORMTYPE = value
        value = find_attr_value_('TRANSFORMKEY', node)
        if value is not None and 'TRANSFORMKEY' not in already_processed:
            already_processed.append('TRANSFORMKEY')
            self.TRANSFORMKEY = value
        value = find_attr_value_('TRANSFORMBEHAVIOR', node)
        if value is not None and 'TRANSFORMBEHAVIOR' not in already_processed:
            already_processed.append('TRANSFORMBEHAVIOR')
            self.TRANSFORMBEHAVIOR = value
        value = find_attr_value_('TRANSFORMALGORITHM', node)
        if value is not None and 'TRANSFORMALGORITHM' not in already_processed:
            already_processed.append('TRANSFORMALGORITHM')
            self.TRANSFORMALGORITHM = value
        value = find_attr_value_('TRANSFORMORDER', node)
        if value is not None and 'TRANSFORMORDER' not in already_processed:
            already_processed.append('TRANSFORMORDER')
            try:
                self.TRANSFORMORDER = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.TRANSFORMORDER <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class transformFileType


class mets(metsType):
    """METS: Metadata Encoding and Transmission Standard. METS is intended
    to provide a standardized XML format for transmission of complex
    digital library objects between systems. As such, it can be seen
    as filling a role similar to that defined for the Submission
    Information Package (SIP), Archival Information Package (AIP)
    and Dissemination Information Package (DIP) in the Reference
    Model for an Open Archival Information System. The root element
    <mets> establishes the container for the information being
    stored and/or transmitted by the standard."""
    subclass = None
    superclass = metsType
    def __init__(self, PROFILE=None, LABEL=None, TYPE=None, ID=None, OBJID=None, metsHdr=None, dmdSec=None, amdSec=None, fileSec=None, structMap=None, structLink=None, behaviorSec=None):
        super(mets, self).__init__(PROFILE, LABEL, TYPE, ID, OBJID, metsHdr, dmdSec, amdSec, fileSec, structMap, structLink, behaviorSec, )
        pass
    def factory(*args_, **kwargs_):
        if mets.subclass:
            return mets.subclass(*args_, **kwargs_)
        else:
            return mets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='mets', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mets'):
        super(mets, self).exportAttributes(outfile, level, already_processed, namespace_, name_='mets')
    def exportChildren(self, outfile, level, namespace_='', name_='mets', fromsubclass_=False, pretty_print=True):
        super(mets, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(mets, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(mets, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(mets, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(mets, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(mets, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class mets


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if Verbose_parse_:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if Verbose_parse_:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(sys.stdout, 0, name_="mets",
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if Verbose_parse_:
        sys.stdout.write('#from mets_eARD import *\n\n')
        sys.stdout.write('import mets_eARD as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "FContentType",
    "FLocatType",
    "agentType",
    "altRecordIDType",
    "amdSecType",
    "areaType",
    "behaviorSecType",
    "behaviorType",
    "divType",
    "fileGrpType",
    "fileGrpType1",
    "fileSecType",
    "fileType",
    "fptrType",
    "mdRefType",
    "mdSecType",
    "mdWrapType",
    "mets",
    "metsDocumentIDType",
    "metsHdrType",
    "metsType",
    "mptrType",
    "objectType",
    "parType",
    "seqType",
    "smArcLinkType",
    "smLinkGrpType",
    "smLinkType",
    "smLocatorLinkType",
    "streamType",
    "structLinkType",
    "structLinkType1",
    "structMapType",
    "transformFileType",
    "xmlDataType",
    "xmlDataType1"
    ]
